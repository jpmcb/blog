<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Why types in programming languages matter. | John McBride</title>
<meta name=keywords content><meta name=description content="Loosely typed programming languages have been around for a very, very long time.
And they’ve been the center of many problems for about as long.
One of the first modern “typeless” programming languages was Ken Thompson’s B: a
machine independent language who’s primary use was for very early Unix systems
development at the legendary Bell laboratory in 1969. Before Dennis Ritchie
(along with Ken) went on to invent the ground breaking, seminal C programming
language, they both used, designed, and developed B."><meta name=author content><link rel=canonical href=https://johncodes.com/posts/2023/09-10-why-types-matter/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://johncodes.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://johncodes.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://johncodes.com/favicon-32x32.png><link rel=apple-touch-icon href=https://johncodes.com/apple-touch-icon.png><link rel=mask-icon href=https://johncodes.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://johncodes.com/posts/2023/09-10-why-types-matter/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Why types in programming languages matter."><meta property="og:description" content="Loosely typed programming languages have been around for a very, very long time.
And they’ve been the center of many problems for about as long.
One of the first modern “typeless” programming languages was Ken Thompson’s B: a
machine independent language who’s primary use was for very early Unix systems
development at the legendary Bell laboratory in 1969. Before Dennis Ritchie
(along with Ken) went on to invent the ground breaking, seminal C programming
language, they both used, designed, and developed B."><meta property="og:type" content="article"><meta property="og:url" content="https://johncodes.com/posts/2023/09-10-why-types-matter/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-10T00:00:00+00:00"><meta property="article:modified_time" content="2023-09-10T00:00:00+00:00"><meta property="og:site_name" content="John-McBride"><meta name=twitter:card content="summary"><meta name=twitter:title content="Why types in programming languages matter."><meta name=twitter:description content="Loosely typed programming languages have been around for a very, very long time.
And they’ve been the center of many problems for about as long.
One of the first modern “typeless” programming languages was Ken Thompson’s B: a
machine independent language who’s primary use was for very early Unix systems
development at the legendary Bell laboratory in 1969. Before Dennis Ritchie
(along with Ken) went on to invent the ground breaking, seminal C programming
language, they both used, designed, and developed B."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://johncodes.com/posts/"},{"@type":"ListItem","position":2,"name":"Why types in programming languages matter.","item":"https://johncodes.com/posts/2023/09-10-why-types-matter/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Why types in programming languages matter.","name":"Why types in programming languages matter.","description":"Loosely typed programming languages have been around for a very, very long time. And they’ve been the center of many problems for about as long.\nOne of the first modern “typeless” programming languages was Ken Thompson’s B: a machine independent language who’s primary use was for very early Unix systems development at the legendary Bell laboratory in 1969. Before Dennis Ritchie (along with Ken) went on to invent the ground breaking, seminal C programming language, they both used, designed, and developed B.\n","keywords":[],"articleBody":"Loosely typed programming languages have been around for a very, very long time. And they’ve been the center of many problems for about as long.\nOne of the first modern “typeless” programming languages was Ken Thompson’s B: a machine independent language who’s primary use was for very early Unix systems development at the legendary Bell laboratory in 1969. Before Dennis Ritchie (along with Ken) went on to invent the ground breaking, seminal C programming language, they both used, designed, and developed B.\nB sort of looks like typical C mixed in with modern Go (and knowing that, you wouldn’t be surprised to find that Ken Thompson years latter had a big hand in designing Go at Google in the early 2000s).\nLet’s take a quick peak at a “Hello, World!” program in B:\nmain() { /* use an external stdlib putchar to print to the screen */ extern putchar; /* declare and assign variables with automatic storage duration */ auto msg, i; msg = \"Hello, World!\\\\n\"; /* iterate each char within the msg until 0 (or in more modern terms, null) is reached */ i = 0; while (msg[i] != 0) { putchar(msg[i]); i = i + 1; } } To say that B is “typeless” isn’t necessarily correct. It has just one type: the “word”.\nFor those unfamiliar with lower level systems programming, a word is typically an abstraction for a processor’s standard memory format. So, on modern 64-bit systems, a word would be 64 bits wide (or more often just referred to as 8 bytes). Within that word, you can store just about anything: integers, strings, address pointers, stack references, etc. In the end, it all gets dereferenced as raw memory and it’s sort of up to the programmer to know what to do with those bits.\nB also came with some nice quality of life features that would latter resurface in C and Go: the auto keyword automatically allocates and manages memory for the duration of the scope it’s being held within. Modern operands like ++ and --. Function declaration. And much more.\nIn Ken Thompson’s own words:\n“B and the old old C were very very similar languages except for all the types [in C]”.\nEarly on, B compiled down to “threaded code”: essentially a script that called many other subroutines and system calls. This made sense at the time since it worked well with the rudimentary operating systems and small bit architectures Ken was working within. But eventually, as year over year leaps and bounds continued within Bell labs computer systems, Richie converted the compiler to produce raw machine code that resulted in safer data typing for variables (see where we might be going here?).\nWhat’s important to understand is that B was a high level programming language that initially used an extremely loose type system: accessing a variable usually meant you would be dereferencing the underlying memory within that word without any checks to its bounds.\nYou can imagine the problems this produced: even in our rudimentary “hello world” program above, there’s a huge assumption that msg is indeed a string (and not a number or function address).\nThese “type assumptions” by programmers can create some really nasty bugs. A similar example of these dangerous assumptions is the classic C buffer overflow:\n#include int main() { // A character buffer array of only 10 chars char buffer[10]; // A null terminated string array // (notice it's abit longer than 10 chars) char message[] = \"Hello, World!\"; // Copy the message directly into the buffer. // Note that there is no effort to check the bounds of the buffer // which results in a buffer overflow. // // C allows for writing past buffer[9] which enters the realm of // \"undefined behavior\": It might work. It might overwrite // other variables in the stack. It might crash the running program. // Or, depending on the system, it may even cause a hardware // exception if some important system memory is overwritten. for (int i = 0; i \u003c sizeof(message); i++) { buffer[i] = message[i]; } // This is very similar to the loop in B we wrote: // Iterate the buffer array until the null terminator is found // // Again, depending on the system and user permissions running this, // we enter the world of \"undefined behavior\": reading bytes in // memory far beyond the original allocation may crash the program // or cause an exception to be thrown. int j = 0; while (buffer[j] != '\\\\0') { putchar(buffer[j]); j++; } return 0; } This is a classic buffer overflow: a program is accessing and writing memory that it really shouldn’t. It demonstrates a few things: sensible checks by the programmer on the “kind” of memory being accessed are ignored which leads to buggy and undefined behavior. It also shows how a very strong typing system would prevent something like this: copy from one buffer to another in languages like Go are relatively safe because of the compiler’s strongly typed interfaces and boundaries.\nUsing a modern “loose” or dynamic typing system is a bit different but replicating similar unintended behavior is not difficult: accessing portions of memory (or the “shapes” of that memory) deep within a language’s systems can have very unintended consequences.\nLet’s look at a JavaScript example now:\nfunction printchars(str) { for(let i = 0; i \u003c str.length; i++) { console.log(str[i]); } } // Yikes! This is the wrong type and should have been a string!!! // // Thanks to type coercion in js, this will inevitably become \"12345\" // and adopt the \"length\" property and not throw an error. // // But the real question remains: // what was the intent here? Why did the caller assume they could use // a number here? What confusion occurred? Or maybe they embraced the // type coercion and forced the function to print a string // of their number. Which in itself is confusing and abit obtuse. let myData = 12345; printchars(myData); I anticipate that JavaScript enthusiasts will not appreciate that example. And I can sympathize! Type coercion can be a very powerful tool and helps to prevent the types of crashes that usually occur in a more rigid type system. But I hope you see the danger here: human communication. Not only between co-workers (I can’t imagine shipping the above code and assuming my co-workers would all understand why I used a printchars function with a number) but also with yourself (I’ve come back to “clever” solutions in personal projects pretty confused why I wrote something the way I did).\nTaking an even bigger step back, throughout history, these sorts of “type” problems have had catastrophic results.\nIn 1996, the European Space Agency was slated to launch their new Ariane 5 rocket: a cutting edge engine that would provide heavy lift space launches for satellites, orbital missions, and much more. Like the Falcon 9 rocket, it was intended primarily for communication satellite missions. Maybe one of it’s most famous flights was in December 2021 when it launched the James Webb Space Telescope and was a huge part in the international effort.\nThe Ariane 5 originally inherited its software from the Ariane 4 rocket, a system that had worked for years without problem. But during the first launch, carrying a payload of satellites, a problem occurred: a 64-bit floating point number that represented the rocket’s horizontal velocity was converted into a 16-bit integer. Since the Ariane 5 had different flight dynamics compared to it’s younger sibling, the value was much much larger than anticipated and could not be converted.\nThis failed conversion resulted in an overflow (sound familiar?), which was not caught and caused a hardware exception. Unfortunately, the rocket’s flight software wasn’t designed to handle this kind of exception and the fault-tolerant design of the system switched to a backup system, but that subsequent system failed in the same way, leading the rocket to go off course. This cascading effect of failed type conversions continued until the rocket was so off course that the self-destruct mechanism was triggered within the mechanical failsafes. This ultimately resulted in a complete loss of the rocket and its satellite payload.\nAt the time, some estimates put the cost of this extraordinary failure at over $300 million USD.\nBy this point, you probably realize that this is a late, veiled critique of DHH’s recent declaration that “Turbo 8 is dropping TypeScript” in favor of regular, vanilla JavaScript:\nTypeScript just gets in the way of that for me. Not just because it requires an explicit compile step, but because it pollutes the code with type gymnastics that add ever so little joy to my development experience, and quite frequently considerable grief. Things that should be easy become hard, and things that are hard become any. No thanks!\nI’ve personally never heard of a project going from a strongly typed system to a loosely typed one. But essentially what this introduces is an insurmountable number of possible bugs and potential catastrophic failures that would be caught by a typing system.\nPeople (and thought leaders) are all entitled to their own opinion. But when it gets dangerous is when you ship a library (like Turbo) that is in use by others. The true tragedy here is not the bad opinions: it’s the rug pull performed in one fell swoop through a single PR. I encourage everyone using Turbo to think deeply about the potential side effects this decision might have on your product and your users: DHH didn’t consider this effect for their users.\nHumans are bad at programming. Our brains weren’t really built to think so rigidly and consider all the possibilities when building systems. Strongly typed systems are tools. And like any good tool, it helps us go further, safer.\nIf you’re a space nerd like me and interested in the Ariane 5 maiden voyage, flight V88, I highly recommend this made for TV documentary from the late 90s. It’s also abit of fascinating TV history and was a great watch while researching this piece.\n","wordCount":"1678","inLanguage":"en","datePublished":"2023-09-10T00:00:00Z","dateModified":"2023-09-10T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://johncodes.com/posts/2023/09-10-why-types-matter/"},"publisher":{"@type":"Organization","name":"John McBride","logo":{"@type":"ImageObject","url":"https://johncodes.com/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://johncodes.com/ accesskey=h title="John McBride (Alt + H)">John McBride</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://johncodes.com/archives title=Writing><span>Writing</span></a></li><li><a href=https://johncodes.com/index.xml title=RSS><span>RSS</span></a></li><li><a href=https://johncodes.com/talks/ title=Talks><span>Talks</span></a></li><li><a href=https://johncodes.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://johncodes.com/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Why types in programming languages matter.</h1><div class=post-meta><span title='2023-09-10 00:00:00 +0000 UTC'>September 10, 2023</span></div></header><div class=post-content><p>Loosely typed programming languages have been around for a very, very long time.
And they’ve been the center of many problems for about as long.</p><p>One of the first modern “typeless” programming languages was Ken Thompson’s B: a
machine independent language who’s primary use was for very early Unix systems
development at the legendary Bell laboratory in 1969. Before Dennis Ritchie
(along with Ken) went on to invent the ground breaking, seminal C programming
language, they both used, designed, and developed B.</p><p>B sort of looks like typical C mixed in with modern Go (and knowing that, you
wouldn’t be surprised to find that Ken Thompson years latter had a big hand in
designing Go at Google in the early 2000s).</p><p>Let’s take a quick peak at a “Hello, World!” program in B:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* use an external stdlib putchar to print to the screen */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>extern</span> putchar;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* declare and assign variables with automatic storage duration */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>auto</span> msg, i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    msg <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello, World!</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>n&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* iterate each char within the msg
</span></span></span><span style=display:flex><span><span style=color:#75715e>       until 0 (or in more modern terms, null) is reached */</span>
</span></span><span style=display:flex><span>    i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (msg[i] <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>putchar</span>(msg[i]);
</span></span><span style=display:flex><span>        i <span style=color:#f92672>=</span> i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To say that B is “typeless” isn’t necessarily correct. It has just one type: the
“word”.</p><p>For those unfamiliar with lower level systems programming, a word is typically
an abstraction for a processor’s standard memory format. So, on modern 64-bit
systems, a word would be 64 bits wide (or more often just referred to as 8
bytes). Within that word, you can store just about anything: integers, strings,
address pointers, stack references, etc. In the end, it all gets dereferenced as
raw memory and it’s sort of up to the programmer to know what to do with those
bits.</p><p>B also came with some nice quality of life features that would latter resurface
in C and Go: the auto keyword automatically allocates and manages memory for the
duration of the scope it’s being held within. Modern operands like <code>++</code> and <code>--</code>.
Function declaration. And much more.</p><p>In Ken Thompson’s own words:</p><blockquote><p>&ldquo;B and the old old C were very very similar languages except for all the types [in C]”.</p></blockquote><p>Early on, B compiled down to “threaded code”: essentially a script that called
many other subroutines and system calls. This made sense at the time since it
worked well with the rudimentary operating systems and small bit architectures
Ken was working within. But eventually, as year over year leaps and bounds
continued within Bell labs computer systems, Richie converted the compiler to
produce raw machine code that resulted in safer data typing for variables (see
where we might be going here?).</p><p>What’s important to understand is that B was a high level programming language
that initially used an extremely loose type system: accessing a variable usually
meant you would be dereferencing the underlying memory within that word without
any checks to its bounds.</p><p>You can imagine the problems this produced: even in our rudimentary “hello
world” program above, there’s a huge assumption that <code>msg</code> is indeed a string (and
not a number or function address).</p><p>These “type assumptions” by programmers can create some really nasty bugs. A
similar example of these dangerous assumptions is the classic C buffer overflow:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// A character buffer array of only 10 chars
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>char</span> buffer[<span style=color:#ae81ff>10</span>];
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>    <span style=color:#75715e>// A null terminated string array
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// (notice it&#39;s abit longer than 10 chars)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>char</span> message[] <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Hello, World!&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Copy the message directly into the buffer.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Note that there is no effort to check the bounds of the buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// which results in a buffer overflow.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// C allows for writing past buffer[9] which enters the realm of
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// &#34;undefined behavior&#34;: It might work. It might overwrite
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// other variables in the stack. It might crash the running program.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Or, depending on the system, it may even cause a hardware
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// exception if some important system memory is overwritten.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>sizeof</span>(message); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        buffer[i] <span style=color:#f92672>=</span> message[i];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This is very similar to the loop in B we wrote:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Iterate the buffer array until the null terminator is found
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Again, depending on the system and user permissions running this,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// we enter the world of &#34;undefined behavior&#34;: reading bytes in
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// memory far beyond the original allocation may crash the program
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// or cause an exception to be thrown.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (buffer[j] <span style=color:#f92672>!=</span> <span style=color:#960050;background-color:#1e0010>&#39;\\</span><span style=color:#ae81ff>0</span><span style=color:#960050;background-color:#1e0010>&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>putchar</span>(buffer[j]);
</span></span><span style=display:flex><span>        j<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is a classic buffer overflow: a program is accessing and writing memory
that it really shouldn’t. It demonstrates a few things: sensible checks by the
programmer on the “kind” of memory being accessed are ignored which leads to
buggy and undefined behavior. It also shows how a very strong typing system
would prevent something like this: copy from one buffer to another in languages
like Go are relatively safe because of the compiler’s strongly typed interfaces
and boundaries.</p><p>Using a modern “loose” or dynamic typing system is a bit different but
replicating similar unintended behavior is not difficult: accessing portions of
memory (or the <em><strong>“shapes”</strong></em> of that memory) deep within a language’s systems can
have very unintended consequences.</p><p>Let’s look at a JavaScript example now:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>printchars</span>(<span style=color:#a6e22e>str</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>str</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>str</span>[<span style=color:#a6e22e>i</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Yikes! This is the wrong type and should have been a string!!!
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Thanks to type coercion in js, this will inevitably become &#34;12345&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e>// and adopt the &#34;length&#34; property and not throw an error.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// But the real question remains: 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// what was the intent here? Why did the caller assume they could use
</span></span></span><span style=display:flex><span><span style=color:#75715e>// a number here? What confusion occurred? Or maybe they embraced the
</span></span></span><span style=display:flex><span><span style=color:#75715e>// type coercion and forced the function to print a string 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// of their number. Which in itself is confusing and abit obtuse.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>myData</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>12345</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>printchars</span>(<span style=color:#a6e22e>myData</span>);
</span></span></code></pre></div><p>I anticipate that JavaScript enthusiasts will not appreciate that example. And I
can sympathize! Type coercion can be a very powerful tool and helps to prevent
the types of crashes that usually occur in a more rigid type system. But I hope
you see the danger here: human communication. Not only between co-workers (I
can’t imagine shipping the above code and assuming my co-workers would all
understand why I used a <code>printchars</code> function with a number) but also with
yourself (I’ve come back to “clever” solutions in personal projects pretty
confused why I wrote something the way I did).</p><hr><p>Taking an even bigger step back, throughout history, these sorts of “type”
problems have had catastrophic results.</p><p>In 1996, the European Space Agency was slated to launch their new Ariane 5
rocket: a cutting edge engine that would provide heavy lift space launches for
satellites, orbital missions, and much more. Like the Falcon 9 rocket, it was
intended primarily for communication satellite missions. Maybe one of it’s most
famous flights was in December 2021 when it launched the James Webb Space
Telescope and was a huge part in the international effort.</p><p>The Ariane 5 originally inherited its software from the Ariane 4 rocket, a
system that had worked for years without problem. But during the first launch,
carrying a payload of satellites, a problem occurred: a 64-bit floating point
number that represented the rocket&rsquo;s horizontal velocity was converted into a
16-bit integer. Since the Ariane 5 had different flight dynamics compared to
it’s younger sibling, the value was much much larger than anticipated and could
not be converted.</p><p>This failed conversion resulted in an overflow (sound familiar?), which was not
caught and caused a hardware exception. Unfortunately, the rocket’s flight
software wasn&rsquo;t designed to handle this kind of exception and the fault-tolerant
design of the system switched to a backup system, but that subsequent system
failed in the same way, leading the rocket to go off course. This cascading
effect of failed type conversions continued until the rocket was so off course
that the self-destruct mechanism was triggered within the mechanical failsafes.
This ultimately resulted in a complete loss of the rocket and its satellite
payload.</p><p>At the time, some estimates put the cost of this extraordinary failure at over
$300 million USD.</p><p>By this point, you probably realize that this is a late, veiled critique of
DHH’s recent declaration that “Turbo 8 is dropping TypeScript” in favor of
regular, vanilla JavaScript:</p><blockquote><p>TypeScript just gets in the way of that for me. Not just because it requires
an explicit compile step, but because it pollutes the code with type
gymnastics that add ever so little joy to my development experience, and
quite frequently considerable grief. Things that should be easy become hard,
and things that are hard become any. No thanks!</p></blockquote><p>I’ve personally never heard of a project going from a strongly typed system to a
loosely typed one. But essentially what this introduces is an insurmountable
number of possible bugs and potential catastrophic failures that would be caught
by a typing system.</p><p>People (and thought leaders) are all entitled to their own opinion. But when it
gets dangerous is when you ship a library (like Turbo) that is in use by others.
The true tragedy here is not the bad opinions: it’s the rug pull performed in
one fell swoop through a single PR. I encourage everyone using Turbo to think
deeply about the potential side effects this decision might have on your product
and your users: DHH didn’t consider this effect for their users.</p><p>Humans are bad at programming. Our brains weren’t really built to think so
rigidly and consider all the possibilities when building systems. Strongly typed
systems are tools. And like any good tool, it helps us go further, safer.</p><hr><p>If you’re a space nerd like me and interested in the Ariane 5 maiden voyage,
flight V88, I highly recommend this made for TV documentary from the late 90s.
It’s also abit of fascinating TV history and was a great watch while researching
this piece.</p><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/DGPwHq8J7_s?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen loading=eager referrerpolicy=strict-origin-when-cross-origin src="https://www.youtube.com/embed/3bujoNtjgTU?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 title="YouTube video"></iframe></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://johncodes.com/>John McBride</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>