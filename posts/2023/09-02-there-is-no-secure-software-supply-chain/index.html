<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>There is no secure software supply-chain. | John McBride</title>
<meta name=keywords content><meta name=description content="Years ago, entrepreneurs and innovators predicated that
“software would eat the world”.
And to little surprise, year after year, the world has become more and
more reliant on software solutions. Often times, that software is (or
indirectly depends on) some open source software, maintained by a group of
people whose only affiliation to one another may be participation in that open
source project’s community.
But we’re in trouble. The security of open source
software is under threat and we’re running out of people to reliably maintain
those projects. And as our stacks get deeper, our dependencies become more
interlinked, leading to terrifying compromises in the secure software
supply-chain. For a perfect example of what’s happening in the open source
world right now, we don’t need to look much further than the extremely popular
Gorilla toolkit for Go."><meta name=author content><link rel=canonical href=https://johncodes.com/posts/2023/09-02-there-is-no-secure-software-supply-chain/><link crossorigin=anonymous href=/assets/css/stylesheet.9329d037bc79464b26647fb72e079cd738f5d2418b1df4da3b515db9e22cb4d9.css integrity="sha256-kynQN7x5RksmZH+3Lgec1zj10kGLHfTaO1FdueIstNk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://johncodes.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://johncodes.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://johncodes.com/favicon-32x32.png><link rel=apple-touch-icon href=https://johncodes.com/apple-touch-icon.png><link rel=mask-icon href=https://johncodes.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://johncodes.com/posts/2023/09-02-there-is-no-secure-software-supply-chain/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="There is no secure software supply-chain."><meta property="og:description" content="Years ago, entrepreneurs and innovators predicated that
“software would eat the world”.
And to little surprise, year after year, the world has become more and
more reliant on software solutions. Often times, that software is (or
indirectly depends on) some open source software, maintained by a group of
people whose only affiliation to one another may be participation in that open
source project’s community.
But we’re in trouble. The security of open source
software is under threat and we’re running out of people to reliably maintain
those projects. And as our stacks get deeper, our dependencies become more
interlinked, leading to terrifying compromises in the secure software
supply-chain. For a perfect example of what’s happening in the open source
world right now, we don’t need to look much further than the extremely popular
Gorilla toolkit for Go."><meta property="og:type" content="article"><meta property="og:url" content="https://johncodes.com/posts/2023/09-02-there-is-no-secure-software-supply-chain/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-09-03T09:00:00+00:00"><meta property="article:modified_time" content="2023-09-03T09:00:00+00:00"><meta property="og:site_name" content="John-McBride"><meta name=twitter:card content="summary"><meta name=twitter:title content="There is no secure software supply-chain."><meta name=twitter:description content="Years ago, entrepreneurs and innovators predicated that
“software would eat the world”.
And to little surprise, year after year, the world has become more and
more reliant on software solutions. Often times, that software is (or
indirectly depends on) some open source software, maintained by a group of
people whose only affiliation to one another may be participation in that open
source project’s community.
But we’re in trouble. The security of open source
software is under threat and we’re running out of people to reliably maintain
those projects. And as our stacks get deeper, our dependencies become more
interlinked, leading to terrifying compromises in the secure software
supply-chain. For a perfect example of what’s happening in the open source
world right now, we don’t need to look much further than the extremely popular
Gorilla toolkit for Go."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://johncodes.com/posts/"},{"@type":"ListItem","position":2,"name":"There is no secure software supply-chain.","item":"https://johncodes.com/posts/2023/09-02-there-is-no-secure-software-supply-chain/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"There is no secure software supply-chain.","name":"There is no secure software supply-chain.","description":"Years ago, entrepreneurs and innovators predicated that “software would eat the world”.\nAnd to little surprise, year after year, the world has become more and more reliant on software solutions. Often times, that software is (or indirectly depends on) some open source software, maintained by a group of people whose only affiliation to one another may be participation in that open source project’s community.\nBut we’re in trouble. The security of open source software is under threat and we’re running out of people to reliably maintain those projects. And as our stacks get deeper, our dependencies become more interlinked, leading to terrifying compromises in the secure software supply-chain. For a perfect example of what’s happening in the open source world right now, we don’t need to look much further than the extremely popular Gorilla toolkit for Go.\n","keywords":[],"articleBody":"Years ago, entrepreneurs and innovators predicated that “software would eat the world”.\nAnd to little surprise, year after year, the world has become more and more reliant on software solutions. Often times, that software is (or indirectly depends on) some open source software, maintained by a group of people whose only affiliation to one another may be participation in that open source project’s community.\nBut we’re in trouble. The security of open source software is under threat and we’re running out of people to reliably maintain those projects. And as our stacks get deeper, our dependencies become more interlinked, leading to terrifying compromises in the secure software supply-chain. For a perfect example of what’s happening in the open source world right now, we don’t need to look much further than the extremely popular Gorilla toolkit for Go.\nIn December of 2022, Gorilla was archived, a project that provided powerful web framework technology like mux and sessions. Over its lengthy tenure, it was the de facto Go framework for web servers, routing requests, handling HTTP traffic, and using websockets. It was used by tens of thousands of other software packages and it came as a shock to most people in the Go community that the project would be no more; no longer maintained, no more releases, and no community support. But for anyone paying close enough attention, the signs of turmoil were clear: open calls for maintainers went unanswered, there were few active outside contributors, and the burden of maintainership was very heavy.\nThe Gorilla framework was one of those “important dependencies”. It sat at the critical intersection of providing nice quality of life tools while still securely handling important payloads. Developers would mold their logic around the APIs provided by Gorilla and entire codebases would be shaped by the use of the framework. The community at large trusted Gorilla; the last thing you want in your server is a web framework riddled with bugs and CVEs. In the secure software supply-chain, much like Nginx and OpenSSL, it’s a project that was at the cornerstone of many other supply-chains and dependencies. If something went wrong in the Gorilla framework, it had the potential to impact millions of servers, services, and other projects.\nThe secure software supply-chain is one of those abstract concepts that giant tech companies, security firms, and news outlets all love to buzz wording about. It’s the “idea” that the software you are consuming as a dependency, all the way through your stack, is exactly the software you’re expecting to consume. In other words, it’s the assurance that some hacker didn’t inject a backdoor into a library or build tool you use, compromising your entire product, software library, or even company. Supply-chain attacks are mischievous because they almost never go after the actual intended target. Instead, they compromise some dependency to then go after the intended target.\nThe classic example, still to this day, is the Solar Winds attack: some unnamed, Russian state-backed hacker group was able to compromise the internal Solar Winds build system, leaving any subsequent software built using that system injected with backdoors and exploits. The fallout from this attack was massive. Many government agencies, including the State Department, confirmed massive data breaches. The estimated cost of this attack continues to rise and is estimated to be in the billions of dollars.\nProduct after product have popped up in the last few years to try and solve these problems: software signing solutions, automated security scanning tools, up to date CVE databases, automation bots, AI assisted coding tools, etc. There was even a whole Whitehouse counsel on the subject. The federal government knows this is the most important (and most critically vulnerable) vector to the well being of our nation’s software infrastructure and they’ve been taking direct action to fight these kind of attacks.\nBut the secure software supply-chain is also one of those things that falls apart quickly; without delicate handling and meticulous safeguarding, things go south fast. For months, the Gorilla toolkit had an open call for maintainers, seeking additional people to keep its codebases up to date, secure, and well maintained. But in the end, the Gorilla maintainers couldn’t find enough people to keep the project afloat. Many people volunteered but then were never seen again. And the bar for maintainer-ship was rightfully very high:\njust handing the reins of even a single software package that has north of 13k unique clones a week (mux) is just not something I’d ever be comfortable with. This has tended to play out poorly with other projects.\nAnd in the past, this has played out poorly in other projects:\nIn 2018, GitHub user FallingSnow opened the issue “I don’t know what to say.” in the popular, but somewhat unknown, NPM JavaScript package event-stream. He’d found something very peculiar in recent commits to the library. A new maintainer, not seen in the community before, with what appeared to be an entirely new GitHub account, had committed a strange piece of code directly to the main branch. This unknown new maintainer had also cut a new package to the NPM registry, forcing this change onto anyone tracking the latest packages in their project.\nThe changes looked like this: In a new file, a long inline encrypted string was added. The string would be decoded using some unknown environment variable, and then, that unencrypted string would be injected as a JavaScript module into the package, effectively executing whatever code was hidden behind the encrypted string. In short, unknown code was being deciphered, injected, and executed at runtime.\nThe GitHub issue went viral. And through sheer brute force, abit of luck, and hundreds of commenters, the community was able to decrypt the string, revealing the injected code’s purpose: a crypto-currency “wallet stealer”. If the code detected a specific wallet on the system, it used a known exploit to steal all the crypto stored in that wallet.\nThis exploitative code lived in the event-stream NPM module for months. Going undetected by security scanners, consumers, and the project’s owner. Only when someone in the community who was curious enough to take a look did this obvious code-injection attack become clear. But what made this attack especially bad was that the event-stream module was used by many other modules (and those modules used by other modules, and so on). In theory, this potentially affected thousands of software packages and millions of end-users. Developers who had no idea their JavaScript used event-stream deep in their dependency stack were now suddenly having to quickly patch their code. How was this even possible? Who approved and allowed this to happen?\nThe owner of the GitHub repository, and original author of the code, said:\nhe emailed me and said he wanted to maintain the module, so I gave it to him. I don’t get any thing from maintaining this module, and I don’t even use it anymore, and havn’t for years.\nand\nnote: I no longer have publish rights to this module on npm.\nJust like that, just by asking, some bad actor was able to compromise tens of thousands of software packages, going undetected through the veil of “maintainership”.\nIn the past, I’ve referred to this as “The Risks of Single Maintainer Dependencies”: the overwhelming, often lonely, and sometimes dangerous experience of maintaining a widely distributed software package on your own. Like the owner of event-stream, most solo maintainers drift away, fading into the background to let their software go into disarray.\nThis was the case with Gorilla:\nThe original author and maintainer, moraes, had moved on a long time ago. kisielk and garyburd had the longest run, maintaining a mix of the HTTP libraries and gorilla/websocket respectively. I (elithrar) got involved sometime in 2014 or so, when I noticed kisielk doing a lot of the heavy lifting and wanted to help contribute back to the libraries I was using for a number of personal projects. Since about ~2018 or so, I was the (mostly) sole maintainer of everything but websocket, which is about the same time garyburd put out an (effectively unsuccessful) call for new maintainers there too.\nThe secure software supply-chain will never truly be strong and secure as long as a single solo maintainer is able to disrupt an entire ecosystem of packages by giving their package away to some bad actor. In truth, there is no secure software supply-chain: we are only as strong as the weakest among us and too often, those weak links in the chain are already broken, left to rot, or given up to those with nefarious purposes.\nWhenever I bring up this topic, someone always asks about money. Oh, money, life’s truest satisfaction! And yes! Money can be a powerful motivator for some people. But it’s a sad excuse for what the secure software supply-chain really needs: true reliability. The software industry can throw all the money it wants at maintainers of important open source projects, something Valve has started doing:\nGriffais says the company is also directly paying more than 100 open-source developers to work on the Proton compatibility layer, the Mesa graphics driver, and Vulkan, among other tasks like Steam for Linux and Chromebooks.\nbut at some point, it becomes unreasonable to ask just a handful of people to hold up the integrity, security, and viability of your companies entire product stack. If it’s that important, why not hire some of those people, build a team of maintainers, create processes for contribution, and allocate developer time into the open source? Too often I hear about solving open source problems by just throwing money at it, but at some point, the problems of scaling software delivery outweigh any amount you can possibly pay a few people. Let’s say you were building a house, it might make sense to have one or two people work on the foundation. But if you’re zoning and building an entire city block, I’d sure hope you’d put an entire team on planning, building, and maintaining those foundations. No amount of money will make just a few people build a strong and safe foundation all by themselves. But what we’re asking some open source maintainers to do is to plan, build, and coordinate the foundations for an entire world.\nAnd this is something the Gorilla maintainers recognized as well:\nNo. I don’t think any of us were after money here. The Gorilla Toolkit was, looking back at the most active maintainers, a passion project. We didn’t want it to be a job.\nFor them, it wasn’t about the money, so throwing any amount at the project wouldn’t have helped. It was about the software’s quality, maintainability, and the kind of intrinsic satisfaction it provided.\nSo then, how can we incentivize open source maintainers to maintain their software in a scalable, realistic way? Some people are motivated by the altruistic value they provide to a community. Some are motivated by fame, power, and recognition. Others still just want to have fun and work on something cool. It’s impossible to understand the complicated, interlinked way different people in an open source community are all motivated. Instead, the best solution is obvious: If you are on a team that relies on some piece of open source software, allocate real engineering time to contributing, being apart of the community, and helping maintain that software. Eventually, you’ll get a really good sense of how a project operates and what motivates its main players. And better yet, you’ll help alleviate the heavy burden of solo maintainership.\nSometimes, I like to think of software like its a wooden canoe, its many dependencies making up the wooden strips of the boat. When first built, it seems sturdy, strong, and able to withstand the harshest of conditions. Its first coat of oil finish is fresh and beautiful, its wood grains smooth and unbent. But as the years ware on, eventually, its finish fads, its wooden strips need replacing, and maybe, if it takes on water, it requires time and new material to repair. Neglected long enough, and its wood could mold and rot from the inside, completely compromising the integrity of the boat. And just like a boat, software requires time, energy, maintenance, and “hands-on-deck” to ensure its many links in the secure software supply-chain are strong. Otherwise, the termites of time and the rot of bad-actors weaken links in the chain, compromising the stability of it all.\nIn the end, the maintainers of the Gorilla framework did the right thing: they decommissioned a widely used project that was at risk of rotting from the inside out. And instead of let it live in disarray or potentially fall into the hands of bad actors, it is simply gone. Its link on the chain of software has been purposefully broken to force anyone using it to choose a better, and hopefully, more secure option.\nI do believe that open source software is entitled to a lifecycle — a beginning, a middle, and an end — and that no project is required to live on forever. That may not make everyone happy, but such is life.\nBut earlier this year, people in the Gorilla community noticed something: a new group of individuals from Red Hat had been added as maintainers to the Gorilla GitHub org. Was Red Hat taking the projected over? No, but ironically, the emeritus maintainers had done exactly what they promised they would never do: at the 11th hour, they handed over the project to people with little vetting from the community.\nTo address many comments that we have seen - we would like to clarify that Red Hat is not taking over this project. While the new Core Maintainers all happen to work at Red Hat, our hope is that developers from many different organizations and backgrounds will join the project over time.\nMaybe Gorilla was too important to drift slowly into obscurity and Red Hat rightfully allocated some engineering resources to the project. Gorilla lives on. Here’s hoping the code is in good hands.\nIf you found this blog post valuable, consider subscribing to future posts via RSS or buying me a coffee via GitHub sponsors.\n","wordCount":"2357","inLanguage":"en","datePublished":"2023-09-03T09:00:00Z","dateModified":"2023-09-03T09:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://johncodes.com/posts/2023/09-02-there-is-no-secure-software-supply-chain/"},"publisher":{"@type":"Organization","name":"John McBride","logo":{"@type":"ImageObject","url":"https://johncodes.com/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://johncodes.com/ accesskey=h title="John McBride (Alt + H)">John McBride</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://johncodes.com/archives title=Writing><span>Writing</span></a></li><li><a href=https://johncodes.com/index.xml title=RSS><span>RSS</span></a></li><li><a href=https://johncodes.com/talks/ title=Talks><span>Talks</span></a></li><li><a href=https://johncodes.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://johncodes.com/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>There is no secure software supply-chain.</h1><div class=post-meta><span title='2023-09-03 09:00:00 +0000 UTC'>September 3, 2023</span></div></header><div class=post-content><p>Years ago, entrepreneurs and innovators predicated that
<a href=https://a16z.com/2011/08/20/why-software-is-eating-the-world/>“software would eat the world”.</a></p><p>And to little surprise, year after year, the world has become more and
more reliant on software solutions. Often times, that software is (or
indirectly depends on) some open source software, maintained by a group of
people whose only affiliation to one another may be participation in that open
source project’s community.</p><p>But we’re in trouble. The security of open source
software is under threat and we’re running out of people to reliably maintain
those projects. And as our stacks get deeper, our dependencies become more
interlinked, leading to terrifying compromises in the secure software
supply-chain. For a perfect example of what’s happening in the open source
world right now, we don’t need to look much further than the extremely popular
<a href=https://github.com/orgs/gorilla/repositories>Gorilla toolkit for Go.</a></p><p>In December of 2022, Gorilla was archived, a project
that provided powerful web framework technology like mux and sessions. Over its
lengthy tenure, it was the de facto Go framework for web servers, routing
requests, handling HTTP traffic, and using websockets. It was used by tens of
thousands of other software packages and it came as a shock to most people in
the Go community that the project would be no more; no longer maintained, no
more releases, and no community support. But for anyone paying close enough
attention, the signs of turmoil were clear:
<a href=https://github.com/gorilla/websocket/issues/370>open calls for maintainers</a>
went unanswered, there were few active outside contributors, and the burden of
maintainership was very heavy.</p><p>The Gorilla framework was one of those “important dependencies”. It sat at the
critical intersection of providing nice quality of life tools while still
securely handling important payloads. Developers would mold their logic around
the APIs provided by Gorilla and entire codebases would be shaped by the use of
the framework. The community at large trusted Gorilla; the last thing you want
in your server is a web framework riddled with bugs and CVEs. In the secure
software supply-chain, much like Nginx and OpenSSL, it’s a project that was at
the cornerstone of many other supply-chains and dependencies. If something went
wrong in the Gorilla framework, it had the potential to impact millions of
servers, services, and other projects.</p><p>The secure software supply-chain is one of those abstract concepts that giant
tech companies, security firms, and news outlets all love to buzz wording
about. It’s the “idea” that the software you are consuming as a dependency, all
the way through your stack, is exactly the software you’re expecting to
consume. In other words, it’s the assurance that some hacker didn’t inject a
backdoor into a library or build tool you use, compromising your entire
product, software library, or even company. Supply-chain attacks are mischievous
because they almost never go after the actual intended target. Instead, they
compromise some dependency to then go after the intended target.</p><p>The classic example, still to this day, is
<a href=https://www.gao.gov/blog/solarwinds-cyberattack-demands-significant-federal-and-private-sector-response-infographic>the Solar Winds attack:</a>
some unnamed, Russian state-backed hacker group was able to compromise the internal
Solar Winds build system, leaving any subsequent software built using that
system injected with backdoors and exploits.
<a href=https://www.nytimes.com/2020/12/14/us/politics/russia-hack-nsa-homeland-security-pentagon.html>The fallout from this attack was massive.</a>
Many government agencies, including the State Department, confirmed
massive data breaches. The estimated cost of this attack continues to rise and
<a href=https://www.nytimes.com/2020/12/16/us/politics/russia-hack-putin-trump-biden.html>is estimated to be in the billions of dollars.</a></p><p>Product after product have popped up in the last few years to try and solve
these problems: software signing solutions, automated security scanning tools,
up to date CVE databases, automation bots, AI assisted coding tools, etc. There
was even a whole Whitehouse counsel on the subject. The federal government
knows this is the most important (and most critically vulnerable) vector to the
well being of our nation’s software infrastructure and they’ve been taking
direct action to fight these kind of attacks.</p><p>But the secure software supply-chain is also one of those things that falls
apart quickly; without delicate handling and meticulous safeguarding, things go
south fast. For months, the Gorilla toolkit had an open call for maintainers,
seeking additional people to keep its codebases up to date, secure, and well
maintained. But in the end, the Gorilla maintainers couldn’t find enough people
to keep the project afloat. Many people volunteered but then were never seen
again. <a href=https://github.com/gorilla#gorilla-toolkit>And the bar for maintainer-ship was rightfully very high:</a></p><blockquote><p>just handing the reins of even a single software package that has north of 13k
unique clones a week (mux) is just not something I’d ever be comfortable with.
This has tended to play out poorly with other projects.</p></blockquote><p>And in the past, this has played out poorly in other projects:</p><p>In 2018, GitHub user FallingSnow opened
<a href=https://github.com/dominictarr/event-stream/issues/116>the issue “I don’t know what to say.”</a>
in the popular, but somewhat unknown, NPM JavaScript package event-stream. He&rsquo;d
found something very peculiar in recent commits to the library. A new
maintainer, not seen in the community before, with what appeared to be an
entirely new GitHub account, had committed a strange piece of code directly to
the main branch. This unknown new maintainer had also cut a new package to the
NPM registry, forcing this change onto anyone tracking the latest packages in
their project.</p><p>The changes looked like this: In a new file, a long inline encrypted string was
added. The string would be decoded using some unknown environment variable, and
then, that unencrypted string would be injected as a JavaScript module into the
package, effectively executing whatever code was hidden behind the encrypted
string. In short, unknown code was being deciphered, injected, and executed at
runtime.</p><p>The GitHub issue went viral. And through sheer brute force, abit of luck, and
hundreds of commenters, the community was able to decrypt the string, revealing
the injected code’s purpose: a crypto-currency “wallet stealer”. If the code
detected a specific wallet on the system, it used a known exploit to steal all
the crypto stored in that wallet.</p><p>This exploitative code lived in the event-stream NPM module for months. Going
undetected by security scanners, consumers, and the project’s owner. Only when
someone in the community who was curious enough to take a look did this obvious
code-injection attack become clear. But what made this attack especially bad
was that the event-stream module was used by many other modules (and those
modules used by other modules, and so on). In theory, this potentially affected
thousands of software packages and millions of end-users. Developers who had no
idea their JavaScript used event-stream deep in their dependency stack were now
suddenly having to quickly patch their code. How was this even possible? Who
approved and allowed this to happen?</p><p><a href=https://github.com/dominictarr/event-stream/issues/116#issuecomment-440927400>The owner of the GitHub repository, and original author of the code, said:</a></p><blockquote><p>he emailed me and said he wanted to maintain the module, so I gave it to him. I
don&rsquo;t get any thing from maintaining this module, and I don&rsquo;t even use it
anymore, and havn&rsquo;t for years.</p></blockquote><p>and</p><blockquote><p>note: I no longer have publish rights to this module on npm.</p></blockquote><p>Just like that, just by asking, some bad actor was able to compromise tens of
thousands of software packages, going undetected through the veil of
“maintainership”.</p><p>In the past, I’ve referred to this as “The Risks of Single Maintainer
Dependencies”: the overwhelming, often lonely, and sometimes dangerous
experience of maintaining a widely distributed software package on your own.
Like the owner of event-stream, most solo maintainers drift away, fading into
the background to let their software go into disarray.</p><p><a href=https://github.com/gorilla#gorilla-toolkit>This was the case with Gorilla:</a></p><blockquote><p>The original author and maintainer, moraes, had moved on a long time ago.
kisielk and garyburd had the longest run, maintaining a mix of the HTTP
libraries and gorilla/websocket respectively. I (elithrar) got involved
sometime in 2014 or so, when I noticed kisielk doing a lot of the heavy lifting
and wanted to help contribute back to the libraries I was using for a number of
personal projects. Since about ~2018 or so, I was the (mostly) sole maintainer
of everything but websocket, which is about the same time garyburd put out an
(effectively unsuccessful) call for new maintainers there too.</p></blockquote><p>The secure software supply-chain will never truly be strong and secure as long
as a single solo maintainer is able to disrupt an entire ecosystem of packages
by giving their package away to some bad actor. In truth, there is no secure
software supply-chain: we are only as strong as the weakest among us and too
often, those weak links in the chain are already broken, left to rot, or given
up to those with nefarious purposes.</p><p>Whenever I bring up this topic, someone always asks about money. Oh, money,
life’s truest satisfaction! And yes! Money can be a powerful motivator for some
people. But it’s a sad excuse for what the secure software supply-chain really
needs: true reliability. The software industry can throw all the money it wants
at maintainers of important open source projects,
<a href=https://www.theverge.com/23499215/valve-steam-deck-interview-late-2022>something Valve has started doing:</a></p><blockquote><p>Griffais says the company is also directly paying more than 100 open-source
developers to work on the Proton compatibility layer, the Mesa graphics driver,
and Vulkan, among other tasks like Steam for Linux and Chromebooks.</p></blockquote><p>but at some point, it becomes unreasonable to ask just a handful of people to
hold up the integrity, security, and viability of your companies entire product
stack. If it’s that important, why not hire some of those people, build a team
of maintainers, create processes for contribution, and allocate developer time
into the open source? Too often I hear about solving open source problems by
just throwing money at it, but at some point, the problems of scaling software
delivery outweigh any amount you can possibly pay a few people. Let’s say you
were building a house, it might make sense to have one or two people work on
the foundation. But if you’re zoning and building an entire city block, I’d
sure hope you’d put an entire team on planning, building, and maintaining those
foundations. No amount of money will make just a few people build a strong and
safe foundation all by themselves. But what we’re asking some open source
maintainers to do is to plan, build, and coordinate the foundations for an
entire world.</p><p><a href=https://github.com/gorilla#gorilla-toolkit>And this is something the Gorilla maintainers recognized as well:</a></p><blockquote><p>No. I don’t think any of us were after money here. The Gorilla Toolkit was,
looking back at the most active maintainers, a passion project. We didn’t want
it to be a job.</p></blockquote><p>For them, it wasn’t about the money, so throwing any amount at the project
wouldn’t have helped. It was about the software’s quality, maintainability, and
the kind of intrinsic satisfaction it provided.</p><p>So then, how can we incentivize open source maintainers to maintain their
software in a scalable, realistic way? Some people are motivated by the
altruistic value they provide to a community. Some are motivated by fame,
power, and recognition. Others still just want to have fun and work on
something cool. It’s impossible to understand the complicated, interlinked way
different people in an open source community are all motivated. Instead, the
best solution is obvious: If you are on a team that relies on some piece of
open source software, allocate real engineering time to contributing, being
apart of the community, and helping maintain that software. Eventually, you’ll
get a really good sense of how a project operates and what motivates its main
players. And better yet, you’ll help alleviate the heavy burden of solo
maintainership.</p><p>Sometimes, I like to think of software like its a wooden canoe, its many
dependencies making up the wooden strips of the boat. When first built, it
seems sturdy, strong, and able to withstand the harshest of conditions. Its
first coat of oil finish is fresh and beautiful, its wood grains smooth and
unbent. But as the years ware on, eventually, its finish fads, its wooden
strips need replacing, and maybe, if it takes on water, it requires time and
new material to repair. Neglected long enough, and its wood could mold and rot
from the inside, completely compromising the integrity of the boat. And just
like a boat, software requires time, energy, maintenance, and “hands-on-deck”
to ensure its many links in the secure software supply-chain are strong.
Otherwise, the termites of time and the rot of bad-actors weaken links in the
chain, compromising the stability of it all.</p><p>In the end, the maintainers of the Gorilla framework did the right thing: they
decommissioned a widely used project that was at risk of rotting from the
inside out. And instead of let it live in disarray or potentially fall into the
hands of bad actors, it is simply gone. Its link on the chain of software has
been purposefully broken to force anyone using it to choose a better, and
hopefully, more secure option.</p><blockquote><p>I do believe that open source software is entitled to a lifecycle — a
beginning, a middle, and an end — and that no project is required to live on
forever. That may not make everyone happy, but such is life.</p></blockquote><p>But earlier this year, people in the Gorilla community noticed something:
a new group of individuals from Red Hat had been added as maintainers to the Gorilla GitHub org.
Was Red Hat taking the projected over? No, but ironically, the emeritus maintainers
had done exactly what they promised they would never do: at the 11th hour, they handed
over the project to people with little vetting from the community.</p><blockquote><p>To address many comments that we have seen - we would like to clarify that
Red Hat is not taking over this project. While the new Core Maintainers all
happen to work at Red Hat, our hope is that developers from many different
organizations and backgrounds will join the project over time.</p></blockquote><p>Maybe Gorilla was too important to drift slowly into obscurity and Red Hat
rightfully allocated some engineering resources to the project.
Gorilla lives on. Here&rsquo;s hoping the code is in good hands.</p><hr><p>If you found this blog post valuable,
consider <a href=https://johncodes.com/index.xml>subscribing to future posts via RSS</a>
or <a href=https://github.com/sponsors/jpmcb>buying me a coffee via GitHub sponsors.</a></p><hr><script src=https://giscus.app/client.js data-repo=jpmcb/blog data-repo-id="MDEwOlJlcG9zaXRvcnkxMTYxODMyNjg=" data-category="Blog comments" data-category-id=DIC_kwDOBuzQ5M4CTbHW data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://johncodes.com/>John McBride</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>