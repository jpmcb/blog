<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>4 billion Go if statements | John McBride</title>
<meta name=keywords content><meta name=description content="I recently read this excellent little bit of programming horror
titled: &ldquo;4 billion if statements&rdquo;.
It chronicles how one could use an insane number of hard coded if statements
to check if any given 32 bit number is even or odd. Instead of do this the normal
and efficient way with a modulus operator and for loop,
hard coding if statements requires some clever meta programming,
some custom assembly code, and a nearly 40 GB compiled binary for all the comparisons."><meta name=author content><link rel=canonical href=https://johncodes.com/posts/2023/12-28-4-billon-go-if-statements/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://johncodes.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://johncodes.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://johncodes.com/favicon-32x32.png><link rel=apple-touch-icon href=https://johncodes.com/apple-touch-icon.png><link rel=mask-icon href=https://johncodes.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://johncodes.com/posts/2023/12-28-4-billon-go-if-statements/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="4 billion Go if statements"><meta property="og:description" content="I recently read this excellent little bit of programming horror
titled: &ldquo;4 billion if statements&rdquo;.
It chronicles how one could use an insane number of hard coded if statements
to check if any given 32 bit number is even or odd. Instead of do this the normal
and efficient way with a modulus operator and for loop,
hard coding if statements requires some clever meta programming,
some custom assembly code, and a nearly 40 GB compiled binary for all the comparisons."><meta property="og:type" content="article"><meta property="og:url" content="https://johncodes.com/posts/2023/12-28-4-billon-go-if-statements/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-28T09:00:00+00:00"><meta property="article:modified_time" content="2023-12-28T09:00:00+00:00"><meta property="og:site_name" content="John-McBride"><meta name=twitter:card content="summary"><meta name=twitter:title content="4 billion Go if statements"><meta name=twitter:description content="I recently read this excellent little bit of programming horror
titled: &ldquo;4 billion if statements&rdquo;.
It chronicles how one could use an insane number of hard coded if statements
to check if any given 32 bit number is even or odd. Instead of do this the normal
and efficient way with a modulus operator and for loop,
hard coding if statements requires some clever meta programming,
some custom assembly code, and a nearly 40 GB compiled binary for all the comparisons."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://johncodes.com/posts/"},{"@type":"ListItem","position":2,"name":"4 billion Go if statements","item":"https://johncodes.com/posts/2023/12-28-4-billon-go-if-statements/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"4 billion Go if statements","name":"4 billion Go if statements","description":"I recently read this excellent little bit of programming horror titled: \u0026ldquo;4 billion if statements\u0026rdquo;.\nIt chronicles how one could use an insane number of hard coded if statements to check if any given 32 bit number is even or odd. Instead of do this the normal and efficient way with a modulus operator and for loop, hard coding if statements requires some clever meta programming, some custom assembly code, and a nearly 40 GB compiled binary for all the comparisons.\n","keywords":[],"articleBody":"I recently read this excellent little bit of programming horror titled: “4 billion if statements”.\nIt chronicles how one could use an insane number of hard coded if statements to check if any given 32 bit number is even or odd. Instead of do this the normal and efficient way with a modulus operator and for loop, hard coding if statements requires some clever meta programming, some custom assembly code, and a nearly 40 GB compiled binary for all the comparisons.\nThis all got me thinking: “Could you do this in Go? What sort of limitations are there with the Go compiler?”\nMuch like the original, I started with a very simple Go program and 10 if comparisons:\nimport ( \"fmt\" \"os\" \"strconv\" ) func main() { arg := os.Args[1] if arg == \"\" { panic(\"argument must be provided\") } num, err := strconv.ParseUint(arg, 10, 64) if err != nil { panic(\"could not parse argument as int64\") } if num == 1 { println(fmt.Sprintf(\"%d is odd\", num)) } if num == 2 { println(fmt.Sprintf(\"%d is even\", num)) } if num == 3 { println(fmt.Sprintf(\"%d is odd\", num)) } // etc. etc. } Pretty simple! It gets the argument to the program, parses it as an uint64 integer, and then goes through all the comparisons one by one.\nAnd it works flawlessly:\n$ go run main.go 8 8 is even In order to extend this beyond what I am humanly capable of doing by hand and what I want to spend the rest of my life doing, (if I was to write out each if statement by hand, and it took me 1/2 a second each time, in order to write out all 32 bit numbers, it would take me roughly 292471207.5 millennium to complete) we should also take advantage of some meta programming. Let the computers do the boring stuff quickly!\nHere’s a simple bash script I came up with to drop in some Go code for us to try and compile:\n#!/usr/bin/env bash # The initial boilerplate for the Go program in a heredoc cat \u003c\u003c EOF \u003e main.go package main import ( \"fmt\" \"os\" \"strconv\" ) func main() { arg := os.Args[1] if arg == \"\" { panic(\"number argument must be provided\") } num, err := strconv.ParseInt(arg, 10, 64) if err != nil { panic(\"could not parse argument as int64\") } EOF # A few variables to control the meta programming flow END=1000 ISEVEN=false # Loop through all values, flipping a flag back and forth (since we're not # using the modulus operator to make even/odd comparisons) for ((i=1; i\u003c=END; i++)); do if [[ $ISEVEN = true ]]; then cat \u003c\u003c EOF \u003e\u003e main.go if num == $i { println(fmt.Sprintf(\"%d is even\", num)) } EOF ISEVEN=false else cat \u003c\u003c EOF \u003e\u003e main.go if num == $i { println(fmt.Sprintf(\"%d is odd\", num)) } EOF ISEVEN=true fi done # Close out the main go program echo \"}\" \u003e\u003e main.go This uses one of my favorite bash features, the “heredoc”, in order to drop large string chunks (in this case, Go code) into a file. Note that this only goes up to 1000 if statements (for now …): we’ll slowly increase the number of if statements to see if we can hit any kind of ceiling or limitation.\nAfter running the bash script, let’s build the generated, meta go code:\nCGO_ENABLED=0 go build -gcflags=\"-N\" -a main.go This instructs the Go toolchain (which includes a gc compiler) to do the following:\nDisable gc optimizations with -N: we don’t want the underlying compiler to make any changes to our meta code through compiler trickery. Disable cgo from require a locally linkable C toolchain: I.e., this builds a sole, statically linked binary. Always build the program, no matter if it’s already been built with the -a flag This produces a single main binary that we can run some tests against:\n$ ./main 500 500 is even $ ./main 677 677 is odd Great! Things seem to be working!!\nNow, since we know 1000 if statements works, let’s try to scale this up abit: like the original post, let’s go up to 16 bit integers (which should be 65536 if statements):\n((END=2**16)) This was abit slower and took just under 2 mins:\n$time ./meta.bash ./meta.bash 18.39s user 65.09s system 78% cpu 1:45.79 total and resulted in a main.go file that is over 100,000 lines of code and 5.6M big.\nAfter building, let’s test it out:\n$ ./main 65536 65536 is even $ ./main 6553 6553 is odd $ ./main 32322 32322 is even Excellent! Now, onward to the 32 bit integer holy grail and over 4 billion if statements!!\n((END=2**32)) At first, I let this ignorantly run all night only to come back and find that I had let my bash script consume all available disc on my Macbook (it only has a 500 GB internal drive): by my estimates, the way I wrote the meta Go code boilerplate, a single file would be over 300 GB in size. Things crashed around 1 billion if statements (since it couldn’t write to disc anymore) and I was left with nothing to do but delete the file and reclaim the disc space.\nThere must be a better way!!\nLet’s try using external storage: I had a spare 1TB external SSD laying around that I could run this experiment on. Now, the only thing would be seeing if the read/write speeds on this external drive would be fast enough resulting in a bottleneck.\nUsing the bash script, it took just under 10 minutes (conservatively) to write 1 million if statements to the drive: to reach 4 billion, using this as an anchor point, it will take 40,000 minutes. Or roughly 27 days to complete. Yikes, the read/write on this old drive is really slow. For my internal mac storage to reach 1 million if statements, it takes less than 5 seconds.\nFoiled again!! I was definitely not anticipating disc space and read/write IO being the biggest hurdle here.\nBash is probably not a wise choice at this point: if I want to make the writing to disc fast and efficient, I probably need something more robust: like Go!\nThis Go program is more or less the same as the original bash script, but, with some major improvements: we are using a buffered writer that lets us make significantly fewer writes to disc with bigger chunks! This speeds things up significantly:\npackage main import ( \"bufio\" \"fmt\" \"math\" \"os\" ) // The file on my attached \"Dark-Star\" SSD const META_FILE = \"/Volumes/Dark-Star/4-billion/main.go\" func main() { var err error // Delete/truncate existing bits within main.go file err = os.Truncate(META_FILE, 0) if err != nil { panic(err) } // open main.go file for writing f, err := os.OpenFile(META_FILE, os.O_WRONLY, os.ModeAppend) if err != nil { panic(err) } // close file on exit and check for its returned error defer func() { if err := f.Close(); err != nil { panic(err) } }() // Use a buffered writer and periodically flush w := bufio.NewWriter(f) // Initial Go boilerplate w.Write([]byte(` package main import ( \"os\" \"strconv\" ) func main() { arg := os.Args[1] if arg == \"\" { panic(\"number argument must be provided\") } num, err := strconv.ParseInt(arg, 10, 64) if err != nil { panic(\"could not parse argument as int64\") } `)) err = w.Flush() if err != nil { panic(err) } // Since we're still not using modulous operators, // use a few flags for tracking the number of chunks // written to the buffered writer and for even/odd chunks := 0 isEven := false // Go is nice since it carries constants in the math package // for max ints of varying bit width for i := 1; i \u003c math.MaxUint32; i += 1 { println(i) // Every 10000 writes to the buffer, flush to the main.go file // Note: this is where the actual write to disc happens if chunks \u003e 10000 { err = w.Flush() if err != nil { panic(err) } chunks = 1 } if isEven { // chunk for an even number _, err := fmt.Fprintf(w, string(` if num == %d { println(\"%d is even\") }`), i, i) if err != nil { panic(err) } isEven = false } else { // chunk for an odd number _, err := fmt.Fprintf(w, string(` if num == %d { println(\"%d is odd\") }`), i, i) if err != nil { panic(err) } isEven = true } chunks += 1 } // Write the last closing bracket for the main function w.Write([]byte(` }`)) // flush out any remaining bits and finish up err = w.Flush() if err != nil { panic(err) } } In total, this took just over 3 hours to write to my external SSD! Much better!!\n./main 1722.63s user 4116.48s system 49% cpu 3:16:32.52 total and the main.go file on the external SSD ended up being about 350GB:\n$ ll main.go -rwxrwxrwx@ 1 jpmcb staff 344G Dec 29 15:55 main.go Now, let’s compile it!\n$ CGO_ENABLED=0 go build -a main.go command-line-arguments: /opt/homebrew/Cellar/go/1.21.3/libexec/pkg/tool/darwin_arm64/compile: signal: killed … about an hour latter, it turns out, I don’t have quite enough ram to actually compile this monstrosity.\nWhat’s going on here? As the Go compiler (and the underlying gc compiler) consume the billions and billions of lines of Go code, it loads those contexts into memory. I believe this is a similar limitation the original author ran into when compiling their C code: there’s just not enough memory on the system to consume and compile such a massive program.\nI considered going down the assembly route:\ncmp w1, 1 ; Compare number in the w1 registry with \"1\" b.eg odd ; Print \"odd\" cmp w1, 2 ; Compare number in the w1 registry with \"2\" b.eg even ; Print \"even\" ; ... and many, many more comparisons but this would:\nEssentially replicate Andreas Karlsson’s original experiment Probably be very tedious to do on a Macbook since “Darwin function numbers are considered private by Apple, and are subject to change.” I was able to piece together some of the syscalls through the XNU bsd kernal syscalls header, Apple’s OSS distribution of the kernel for MacOS and iOS. But again, this seemed be a relatively fraught effort replicating what’s already been done on x86. Lessons learned: Building massive Go projects requires an equally massive amount of RAM. External SSD io read/write times can indeed be a scaling issue: I had to pivot to a more efficient, chunking strategy when writing the 300+ GB file to my external drive. Like any massive scale problem, abit of bubble-gum and duct tape is usually required. Sidebar: bash does not support 64 bit wide ints At one point during this journey, I thought that maybe I could keep these shenanigans going and scale this all the way up to 64 bit wide ints.\nBesides how absolutely huge the source file would be (the difference between the max 32 bit int and max 64 bit int is roughly 4 billion times the size: so we can assume the source file would be 400 GB * 4 billion == 16 million petabytes). I found there was a tricky soft limit on ints in bash:\n((NUM=(2**64))) echo $NUM # 0 ((NUM=(2**64) - 1)) echo $NUM # -1 # 2^64 truly results in zero, not just overflowed back around to 0 ((NUM=(2**63))) echo $NUM # -9223372036854775808 # interesting! This seems to overflow ((NUM=(2**63) - 1)) echo $NUM # 9223372036854775807 # This seems to be the upper limit of bit width ints in bash ","wordCount":"1924","inLanguage":"en","datePublished":"2023-12-28T09:00:00Z","dateModified":"2023-12-28T09:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://johncodes.com/posts/2023/12-28-4-billon-go-if-statements/"},"publisher":{"@type":"Organization","name":"John McBride","logo":{"@type":"ImageObject","url":"https://johncodes.com/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://johncodes.com/ accesskey=h title="John McBride (Alt + H)">John McBride</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://johncodes.com/archives title=Writing><span>Writing</span></a></li><li><a href=https://johncodes.com/index.xml title=RSS><span>RSS</span></a></li><li><a href=https://johncodes.com/talks/ title=Talks><span>Talks</span></a></li><li><a href=https://johncodes.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://johncodes.com/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">4 billion Go if statements</h1><div class=post-meta><span title='2023-12-28 09:00:00 +0000 UTC'>December 28, 2023</span></div></header><div class=post-content><p>I recently read <a href=https://andreasjhkarlsson.github.io/jekyll/update/2023/12/27/4-billion-if-statements.html>this <em>excellent</em> little bit of programming horror</a>
titled: <em>&ldquo;4 billion if statements&rdquo;</em>.</p><p>It chronicles how one could use an <em>insane</em> number of hard coded if statements
to check if any given 32 bit number is even or odd. Instead of do this the normal
and efficient way with a modulus operator and <code>for</code> loop,
hard coding if statements requires some clever meta programming,
some custom assembly code, and a nearly 40 GB compiled binary for all the comparisons.</p><p>This all got me thinking:
<em>&ldquo;Could you do this in Go? What sort of limitations are there with the Go compiler?&rdquo;</em></p><p>Much like the original, I started with a very simple Go program and 10 <code>if</code> comparisons:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;os&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;strconv&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>arg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Args</span>[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>arg</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>                panic(<span style=color:#e6db74>&#34;argument must be provided&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>num</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>ParseUint</span>(<span style=color:#a6e22e>arg</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>64</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                panic(<span style=color:#e6db74>&#34;could not parse argument as int64&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>num</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>                println(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%d is odd&#34;</span>, <span style=color:#a6e22e>num</span>))
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>num</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span> {
</span></span><span style=display:flex><span>                println(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%d is even&#34;</span>, <span style=color:#a6e22e>num</span>))
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>num</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span> {
</span></span><span style=display:flex><span>                println(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%d is odd&#34;</span>, <span style=color:#a6e22e>num</span>))
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// etc. etc.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Pretty simple! It gets the argument to the program, parses it as an <code>uint64</code> integer,
and then goes through all the comparisons one by one.</p><p>And it works flawlessly:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ go run main.go 8
</span></span><span style=display:flex><span>8 is even
</span></span></code></pre></div><p>In order to extend this <em>beyond</em> what I am humanly capable of doing by hand and what I want to spend the rest of my life doing,
(if I was to write out each <code>if</code> statement by hand, and it took me 1/2 a second each time,
in order to write out all 32 bit numbers,
it would take me roughly 292471207.5 millennium to complete)
we should also take advantage of some meta programming. Let the computers do the boring stuff quickly!</p><p>Here&rsquo;s a simple bash script I came up with to drop in some Go code
for us to try and compile:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e># The initial boilerplate for the Go program in a heredoc</span>
</span></span><span style=display:flex><span>cat <span style=color:#e6db74>&lt;&lt; EOF &gt; main.go
</span></span></span><span style=display:flex><span><span style=color:#e6db74>package main
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>import (
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;fmt&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;os&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;strconv&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>func main() {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        arg := os.Args[1]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        if arg == &#34;&#34; {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                panic(&#34;number argument must be provided&#34;)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        num, err := strconv.ParseInt(arg, 10, 64)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        if err != nil {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                panic(&#34;could not parse argument as int64&#34;)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># A few variables to control the meta programming flow</span>
</span></span><span style=display:flex><span>END<span style=color:#f92672>=</span><span style=color:#ae81ff>1000</span>
</span></span><span style=display:flex><span>ISEVEN<span style=color:#f92672>=</span>false
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Loop through all values, flipping a flag back and forth (since we&#39;re not</span>
</span></span><span style=display:flex><span><span style=color:#75715e># using the modulus operator to make even/odd comparisons)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#f92672>((</span>i<span style=color:#f92672>=</span>1; i&lt;<span style=color:#f92672>=</span>END; i++<span style=color:#f92672>))</span>; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>[[</span> $ISEVEN <span style=color:#f92672>=</span> true <span style=color:#f92672>]]</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>        cat <span style=color:#e6db74>&lt;&lt; EOF &gt;&gt; main.go
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        if num == $i {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                println(fmt.Sprintf(&#34;%d is even&#34;, num))
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>EOF</span>
</span></span><span style=display:flex><span>        ISEVEN<span style=color:#f92672>=</span>false
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>        cat <span style=color:#e6db74>&lt;&lt; EOF &gt;&gt; main.go
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        if num == $i {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                println(fmt.Sprintf(&#34;%d is odd&#34;, num))
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>EOF</span>
</span></span><span style=display:flex><span>        ISEVEN<span style=color:#f92672>=</span>true
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Close out the main go program</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;}&#34;</span> &gt;&gt; main.go
</span></span></code></pre></div><p>This uses one of my favorite bash features, the &ldquo;heredoc&rdquo;, in order to drop
large string chunks (in this case, Go code) into a file.
Note that this only goes up to 1000 if statements <em>(for now &mldr;)</em>: we&rsquo;ll slowly increase the number of if statements
to see if we can hit any kind of ceiling or limitation.</p><p>After running the bash script, let&rsquo;s build the generated, meta go code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>CGO_ENABLED<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span> go build -gcflags<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-N&#34;</span> -a main.go
</span></span></code></pre></div><p>This instructs the Go toolchain (which includes a <code>gc</code> compiler) to do the following:</p><ul><li>Disable <code>gc</code> optimizations with <code>-N</code>: we don&rsquo;t want the underlying compiler to make
any changes to our meta code through compiler trickery.</li><li>Disable <code>cgo</code> from require a locally linkable C toolchain: I.e., this builds a sole, statically linked binary.</li><li>Always build the program, no matter if it&rsquo;s already been built with the <code>-a</code> flag</li></ul><p>This produces a single <code>main</code> binary that we can run some tests against:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ ./main 500
</span></span><span style=display:flex><span>500 is even
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./main 677
</span></span><span style=display:flex><span>677 is odd
</span></span></code></pre></div><p>Great! Things seem to be working!!</p><p>Now, since we know 1000 if statements works, let&rsquo;s try to scale this up abit:
like the original post, let&rsquo;s go up to 16 bit integers
(which should be 65536 <code>if</code> statements):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>((</span>END<span style=color:#f92672>=</span>2**16<span style=color:#f92672>))</span>
</span></span></code></pre></div><p>This was <em>abit</em> slower and took just under 2 mins:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$time ./meta.bash
</span></span><span style=display:flex><span>./meta.bash  18.39s user 65.09s system 78% cpu 1:45.79 total
</span></span></code></pre></div><p>and resulted in a <code>main.go</code> file that is over 100,000 lines of code and <code>5.6M</code> big.</p><p>After building, let&rsquo;s test it out:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ ./main 65536
</span></span><span style=display:flex><span>65536 is even
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./main 6553
</span></span><span style=display:flex><span>6553 is odd
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ./main 32322
</span></span><span style=display:flex><span>32322 is even
</span></span></code></pre></div><p>Excellent! Now, onward to the 32 bit integer holy grail and over 4 billion if statements!!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>((</span>END<span style=color:#f92672>=</span>2**32<span style=color:#f92672>))</span>
</span></span></code></pre></div><p>At first, I let this ignorantly run <em>all night</em> only to come back and find that I had let my bash script
consume all available disc on my Macbook (it only has a 500 GB internal drive): by my estimates, the way I wrote the meta Go code boilerplate,
a single file would be over 300 GB in size. Things crashed around 1 billion <code>if</code> statements (since it couldn&rsquo;t write to disc anymore)
and I was left with nothing to do but delete the file and reclaim the disc space.</p><p><em>There must be a better way!!</em></p><p>Let&rsquo;s try using external storage: I had a spare 1TB external SSD laying around that I could run this experiment on.
Now, the only thing would be seeing if the read/write speeds on this external drive would be fast enough
resulting in a bottleneck.</p><p>Using the bash script, it took just under 10 minutes (conservatively) to write 1 million <code>if</code> statements to the drive:
to reach 4 billion, using this as an anchor point, it will take 40,000 minutes.
Or roughly 27 days to complete. <em>Yikes, the read/write on this old drive is really slow</em>.
For my internal mac storage to reach 1 million <code>if</code> statements, it takes less than 5 seconds.</p><p><em>Foiled again!!</em> I was definitely not anticipating disc space and read/write IO being the biggest hurdle here.</p><p>Bash is probably <em>not a wise choice</em> at this point: if I want to make the writing to disc
fast and efficient, I probably need something more robust: like Go!</p><p>This Go program is more or less the same as the original bash script,
but, with some major improvements: we are using a buffered writer that lets us
make significantly fewer writes to disc with bigger chunks! This speeds
things up significantly:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;bufio&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;math&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;os&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// The file on my attached &#34;Dark-Star&#34; SSD
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>META_FILE</span> = <span style=color:#e6db74>&#34;/Volumes/Dark-Star/4-billion/main.go&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Delete/truncate existing bits within main.go file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Truncate</span>(<span style=color:#a6e22e>META_FILE</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// open main.go file for writing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>OpenFile</span>(<span style=color:#a6e22e>META_FILE</span>, <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>O_WRONLY</span>, <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>ModeAppend</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// close file on exit and check for its returned error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>defer</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Close</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                        panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>        }()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Use a buffered writer and periodically flush
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>w</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewWriter</span>(<span style=color:#a6e22e>f</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Initial Go boilerplate
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#e6db74>`
</span></span></span><span style=display:flex><span><span style=color:#e6db74>package main
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>import (
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;os&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;strconv&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>func main() {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        arg := os.Args[1]
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        if arg == &#34;&#34; {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                panic(&#34;number argument must be provided&#34;)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        num, err := strconv.ParseInt(arg, 10, 64)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        if err != nil {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                panic(&#34;could not parse argument as int64&#34;)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        }
</span></span></span><span style=display:flex><span><span style=color:#e6db74>`</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Flush</span>()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Since we&#39;re still not using modulous operators,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// use a few flags for tracking the number of chunks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// written to the buffered writer and for even/odd
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>chunks</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>isEven</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Go is nice since it carries constants in the math package
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// for max ints of varying bit width
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MaxUint32</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>                println(<span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Every 10000 writes to the buffer, flush to the main.go file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// Note: this is where the actual write to disc happens
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>chunks</span> &gt; <span style=color:#ae81ff>10000</span> {
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Flush</span>()
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                                panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>chunks</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isEven</span> {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// chunk for an even number
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprintf</span>(<span style=color:#a6e22e>w</span>, string(<span style=color:#e6db74>`
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        if num == %d {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                println(&#34;%d is even&#34;)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        }`</span>), <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                                panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>isEven</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// chunk for an odd number
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprintf</span>(<span style=color:#a6e22e>w</span>, string(<span style=color:#e6db74>`
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        if num == %d {
</span></span></span><span style=display:flex><span><span style=color:#e6db74>                println(&#34;%d is odd&#34;)
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        }`</span>), <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                                panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>isEven</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>chunks</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Write the last closing bracket for the main function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Write</span>([]byte(<span style=color:#e6db74>`
</span></span></span><span style=display:flex><span><span style=color:#e6db74>}`</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// flush out any remaining bits and finish up
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Flush</span>()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In total, this took just over 3 hours to write to my external SSD! Much better!!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>./main  1722.63s user 4116.48s system 49% cpu 3:16:32.52 total
</span></span></code></pre></div><p>and the <code>main.go</code> file on the external SSD ended up being about 350GB:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ ll main.go
</span></span><span style=display:flex><span>-rwxrwxrwx@ 1 jpmcb  staff   344G Dec 29 15:55 main.go
</span></span></code></pre></div><p>Now, let&rsquo;s compile it!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ CGO_ENABLED=0 go build -a main.go
</span></span><span style=display:flex><span>command-line-arguments:
</span></span><span style=display:flex><span>/opt/homebrew/Cellar/go/1.21.3/libexec/pkg/tool/darwin_arm64/compile:
</span></span><span style=display:flex><span>signal: killed
</span></span></code></pre></div><p>&mldr; about an hour latter, it turns out, I don&rsquo;t have <em>quite</em> enough ram to actually compile this monstrosity.</p><p>What&rsquo;s going on here? As the Go compiler (and the underlying <code>gc</code> compiler) consume the billions and billions
of lines of Go code, it loads those contexts into memory. I believe this is a similar limitation the original
author ran into when compiling their C code: there&rsquo;s just not enough memory on the system to consume and compile such a massive program.</p><p>I considered going down the assembly route:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>cmp</span> <span style=color:#66d9ef>w1</span>, <span style=color:#ae81ff>1</span>     <span style=color:#75715e>; Compare number in the w1 registry with &#34;1&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>b.eg</span> <span style=color:#66d9ef>odd</span>      <span style=color:#75715e>; Print &#34;odd&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>cmp</span> <span style=color:#66d9ef>w1</span>, <span style=color:#ae81ff>2</span>     <span style=color:#75715e>; Compare number in the w1 registry with &#34;2&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>b.eg</span> <span style=color:#66d9ef>even</span>     <span style=color:#75715e>; Print &#34;even&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>; ... and many, many more comparisons
</span></span></span></code></pre></div><p>but this would:</p><ol><li>Essentially replicate Andreas Karlsson&rsquo;s original experiment</li><li>Probably be very tedious to do on a Macbook since <em>&ldquo;Darwin function numbers
are considered private by Apple, and are subject to change.&rdquo;</em>
I was able to piece together some of the syscalls through the <a href=https://github.com/apple-oss-distributions/xnu/blob/main/bsd/kern/syscalls.master>XNU bsd kernal syscalls header</a>,
Apple&rsquo;s OSS distribution of the kernel for MacOS and iOS.
But again, this seemed be a relatively fraught effort replicating what&rsquo;s already been done on x86.</li></ol><h3 id=lessons-learned>Lessons learned:<a hidden class=anchor aria-hidden=true href=#lessons-learned>#</a></h3><ul><li>Building massive Go projects requires an equally massive amount of RAM.</li><li>External SSD io read/write times <em>can</em> indeed be a scaling issue:
I had to pivot to a more efficient, chunking strategy when writing the 300+ GB
file to my external drive.</li><li>Like any massive scale problem, abit of bubble-gum and duct tape is usually required.</li></ul><hr><h3 id=sidebar-bash-does-not-support-64-bit-wide-ints>Sidebar: bash does not support 64 bit wide ints<a hidden class=anchor aria-hidden=true href=#sidebar-bash-does-not-support-64-bit-wide-ints>#</a></h3><p>At one point during this journey, I thought that <em>maybe</em>
I could keep these shenanigans going and scale this all
the way up to 64 bit wide ints.</p><p>Besides how absolutely <em>huge</em> the source file would be
(the difference between the max 32 bit int and max 64 bit int
is roughly 4 billion times the size: so we can assume the
source file would be 400 GB * 4 billion == 16 million petabytes).
I found there was a tricky soft limit on ints in bash:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>((</span>NUM<span style=color:#f92672>=(</span>2**64<span style=color:#f92672>)))</span>
</span></span><span style=display:flex><span>echo $NUM
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 0</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>((</span>NUM<span style=color:#f92672>=(</span>2**64<span style=color:#f92672>)</span> - 1<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>echo $NUM
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># -1</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 2^64 truly results in zero, not just overflowed back around to 0</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>((</span>NUM<span style=color:#f92672>=(</span>2**63<span style=color:#f92672>)))</span>
</span></span><span style=display:flex><span>echo $NUM
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># -9223372036854775808</span>
</span></span><span style=display:flex><span><span style=color:#75715e># interesting! This seems to overflow</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>((</span>NUM<span style=color:#f92672>=(</span>2**63<span style=color:#f92672>)</span> - 1<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>echo $NUM
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 9223372036854775807</span>
</span></span><span style=display:flex><span><span style=color:#75715e># This seems to be the upper limit of bit width ints in bash</span>
</span></span></code></pre></div><hr><script src=https://giscus.app/client.js data-repo=jpmcb/blog data-repo-id="MDEwOlJlcG9zaXRvcnkxMTYxODMyNjg=" data-category="Blog comments" data-category-id=DIC_kwDOBuzQ5M4CTbHW data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://johncodes.com/>John McBride</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>