<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Awk: A beginners guide for humans | John McBride</title>
<meta name=keywords content><meta name=description content='Earlier this week, I had a file of names, each delimited by a newline:
john
jack
jill
But really, I needed this file to be in the form:
{
    "full_name": "name"
},
This file wasn&rsquo;t absolutely huge, but it was big enough that editing it manually
would have been annoying. I thought to myself, &ldquo;instead of editing this file manually
or generating it correctly, how can I spend the maximum amount of time
using a bespoke tool to get it in the right format?
A neovim macro? Sed? Write some python? Why not awk!&rdquo;'><meta name=author content><link rel=canonical href=https://johncodes.com/posts/2024/03-03-awk-basics/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://johncodes.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://johncodes.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://johncodes.com/favicon-32x32.png><link rel=apple-touch-icon href=https://johncodes.com/apple-touch-icon.png><link rel=mask-icon href=https://johncodes.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://johncodes.com/posts/2024/03-03-awk-basics/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Awk: A beginners guide for humans"><meta property="og:description" content='Earlier this week, I had a file of names, each delimited by a newline:
john
jack
jill
But really, I needed this file to be in the form:
{
    "full_name": "name"
},
This file wasn&rsquo;t absolutely huge, but it was big enough that editing it manually
would have been annoying. I thought to myself, &ldquo;instead of editing this file manually
or generating it correctly, how can I spend the maximum amount of time
using a bespoke tool to get it in the right format?
A neovim macro? Sed? Write some python? Why not awk!&rdquo;'><meta property="og:type" content="article"><meta property="og:url" content="https://johncodes.com/posts/2024/03-03-awk-basics/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-03T09:00:00+00:00"><meta property="article:modified_time" content="2024-03-03T09:00:00+00:00"><meta property="og:site_name" content="John-McBride"><meta name=twitter:card content="summary"><meta name=twitter:title content="Awk: A beginners guide for humans"><meta name=twitter:description content='Earlier this week, I had a file of names, each delimited by a newline:
john
jack
jill
But really, I needed this file to be in the form:
{
    "full_name": "name"
},
This file wasn&rsquo;t absolutely huge, but it was big enough that editing it manually
would have been annoying. I thought to myself, &ldquo;instead of editing this file manually
or generating it correctly, how can I spend the maximum amount of time
using a bespoke tool to get it in the right format?
A neovim macro? Sed? Write some python? Why not awk!&rdquo;'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://johncodes.com/posts/"},{"@type":"ListItem","position":2,"name":"Awk: A beginners guide for humans","item":"https://johncodes.com/posts/2024/03-03-awk-basics/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Awk: A beginners guide for humans","name":"Awk: A beginners guide for humans","description":"Earlier this week, I had a file of names, each delimited by a newline:\njohn jack jill But really, I needed this file to be in the form:\n{ \u0026#34;full_name\u0026#34;: \u0026#34;name\u0026#34; }, This file wasn\u0026rsquo;t absolutely huge, but it was big enough that editing it manually would have been annoying. I thought to myself, \u0026ldquo;instead of editing this file manually or generating it correctly, how can I spend the maximum amount of time using a bespoke tool to get it in the right format? A neovim macro? Sed? Write some python? Why not awk!\u0026rdquo;\n","keywords":[],"articleBody":"Earlier this week, I had a file of names, each delimited by a newline:\njohn jack jill But really, I needed this file to be in the form:\n{ \"full_name\": \"name\" }, This file wasn’t absolutely huge, but it was big enough that editing it manually would have been annoying. I thought to myself, “instead of editing this file manually or generating it correctly, how can I spend the maximum amount of time using a bespoke tool to get it in the right format? A neovim macro? Sed? Write some python? Why not awk!”\nIn the end, here’s the awk command I used:\nawk '{print \"{\\n \\\"full_name\\\": \\\"\" $0 \"\\\"\\n},\"}' names.txt This printed each line surrounded by the appropriate curly braces and whitespace.\nLet’s break down how I did this and build the command one bit at a time:\nAwk is a Linux command line utility just like any other. But, similar to something like like python or lua, it’s a special program interpreter that is especially good at scanning and processing inputs with small (or big) one liner programs you give it. awk '' some-input-file Let’s start simple and just print the names from the file directly to stdout: awk '{print $0}' names.txt john jack jill within the '', we provide awk with a small program it will execute. This is basically the “hello world” of awk: it just takes each line and prints it out just like it is, unedited, in the file.\nBut what is $0? Awk has the concept of “columns” in a file: these are typically space delimited. So a file like:\n1 2 3 4 5 6 has 3 columns and 2 rows. The $0 variable is a special one and represents the entire row of arguments. Then, each $N is the N-th (where 1 is the first column) argument in that row.\nSo, if we only wanted the 1st column in the above file with 3 columns, we could run the following awk program:\nawk '{print $1}' numbers.txt 1 4 If we only wanted the 2nd and 3rd columns, we could run:\nawk '{print $2 \" \" $3}' numbers.txt 2 3 5 6 (notice the blank \" \" we provide as a string to force some whitespace formatting so the columns are closer to what exists in the original file.\nNext, lets add in some additional text to print out: awk '{print \"{\\\"full_name\\\": \\\"\" $0 \"\\\"},\"}' names.txt First thing you’ll notice is a confusing array of \"\nthe first \" denotes the beginning of a string output for awk to print. The subsequent \\\" are literal escaped quotes which we want to appear in the output. We eventually end the first string with a standalone \" to then print the line with the $0 variable and then we enter a string again to add the trailing bracket } and comma , When run, this outputs:\n{\"full_name\": \"john\"}, {\"full_name\": \"jack\"}, {\"full_name\": \"jill\"}, Now we’re getting somewhere! Let’s finish this off by adding the additional white spacing: awk '{print \"{\\n \\\"full_name\\\": \\\"\" $0 \"\\\"\\n},\"}' names.txt { \"full_name\": \"john\" }, { \"full_name\": \"jack\" }, { \"full_name\": \"jill\" }, The added whitespace within the strings (by including the literal escaped newlines \\n) are printed to give the correct, desired output!\nBonus: what if we wanted to remove the trailing comma? What if we wanted to wrap this all in [...] to be closer to valid json? Yeah, yeah, I know, jq exists, but by the power of our lord and savior awk, all things possible!! To remove the trailing comma, we can use a sliding window technique:\nawk 'NR \u003e 1 {print prev \",\"} {prev = \"{\\n \\\"full_name\\\": \\\"\" $0 \"\\\"\\n}\"} END {print prev}' names.txt This introduces abit more complexity.\nFirst, we add the NR concept: NR is the “number of records”. This can be really useful for checking progress, doing different things based on number of records processed, etc.\nSo, after the first record, we print the comma. We also always store the “previous” chunk in a prev variable: this is the N + 1 sliding window. Nothing actually happens when the first record is processed, it’s line output is simply stored in the prev variable to be printed on the next iteration. This way, we’re always one behind the current record and when we reach the very end (using the END keyword), we can print the previous chunk without the trailing comma!\nTo wrap it up the entire output in a square bracket and give it the correct spacing, we can use this awk program:\nBEGIN { # Print the opening bracket for the JSON array print \"[\" } NR \u003e 1 { # after the first line, print the previously stored chunk print prev \",\" } { # Store the current line in a JSON object format prev = \" {\\n \\\"full_name\\\": \\\"\" $0 \"\\\"\\n }\" } END { # Print the last line stored in prev and close the JSON array print prev \"\\n]\" } We can run this awk program via a file instead of doing all of that on the command line directly. This greatly helps with readability, maintainability, etc.\nawk -f format_names.awk names.txt [ { \"full_name\": \"john\" }, { \"full_name\": \"jack\" }, { \"full_name\": \"jill\" } ] Just like the previous awk program, we are printing each segment and then at the end, leaving off the trailing comma. But this time, at the beginning of the program, using BEGIN and END, we print an opening and closing bracket.\nHappy awk-ing and good luck!\n","wordCount":"923","inLanguage":"en","datePublished":"2024-03-03T09:00:00Z","dateModified":"2024-03-03T09:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://johncodes.com/posts/2024/03-03-awk-basics/"},"publisher":{"@type":"Organization","name":"John McBride","logo":{"@type":"ImageObject","url":"https://johncodes.com/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://johncodes.com/ accesskey=h title="John McBride (Alt + H)">John McBride</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://johncodes.com/archives title=Writing><span>Writing</span></a></li><li><a href=https://johncodes.com/index.xml title=RSS><span>RSS</span></a></li><li><a href=https://johncodes.com/talks/ title=Talks><span>Talks</span></a></li><li><a href=https://johncodes.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://johncodes.com/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Awk: A beginners guide for humans</h1><div class=post-meta><span title='2024-03-03 09:00:00 +0000 UTC'>March 3, 2024</span></div></header><div class=post-content><p>Earlier this week, I had a file of names, each delimited by a newline:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>john
</span></span><span style=display:flex><span>jack
</span></span><span style=display:flex><span>jill
</span></span></code></pre></div><p>But really, I needed this file to be in the form:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>{
</span></span><span style=display:flex><span>    &#34;full_name&#34;: &#34;name&#34;
</span></span><span style=display:flex><span>},
</span></span></code></pre></div><p>This file wasn&rsquo;t absolutely huge, but it was big enough that editing it manually
would have been annoying. I thought to myself, &ldquo;instead of editing this file manually
or generating it correctly, how can I spend the maximum amount of time
using a bespoke tool to get it in the right format?
A neovim macro? Sed? Write some python? Why not awk!&rdquo;</p><p>In the end, here&rsquo;s the awk command I used:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>awk <span style=color:#e6db74>&#39;{print &#34;{\n    \&#34;full_name\&#34;: \&#34;&#34; $0 &#34;\&#34;\n},&#34;}&#39;</span> names.txt
</span></span></code></pre></div><p>This printed each line surrounded by the appropriate curly braces and whitespace.</p><hr><p>Let&rsquo;s break down how I did this and build the command one bit at a time:</p><ol><li>Awk is a Linux command line utility just like any other.
But, similar to something like like python or lua,
it&rsquo;s a special program interpreter that is especially
good at scanning and processing inputs with small (or big) one liner programs you give it.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>awk <span style=color:#e6db74>&#39;&lt;an-awk-program&gt;&#39;</span> some-input-file
</span></span></code></pre></div><ol start=2><li>Let&rsquo;s start simple and just print the names from the file directly to stdout:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>awk <span style=color:#e6db74>&#39;{print $0}&#39;</span> names.txt
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>john
</span></span><span style=display:flex><span>jack
</span></span><span style=display:flex><span>jill
</span></span></code></pre></div><p>within the <code>''</code>, we provide awk with a small program it will execute.
This is basically the &ldquo;hello world&rdquo; of awk: it just takes each line and prints it out
just like it is, unedited, in the file.</p><p>But what is <code>$0</code>?
Awk has the concept of &ldquo;columns&rdquo; in a file: these are typically space delimited.
So a file like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>1 2 3
</span></span><span style=display:flex><span>4 5 6 
</span></span></code></pre></div><p>has 3 columns and 2 rows.
The <code>$0</code> variable is a special one and represents the entire row of arguments.
Then, each <code>$N</code> is the N-th (where 1 is the first column) argument in that row.</p><p>So, if we only wanted the 1st column in the above file with 3 columns,
we could run the following awk program:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>awk <span style=color:#e6db74>&#39;{print $1}&#39;</span> numbers.txt
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>1
</span></span><span style=display:flex><span>4
</span></span></code></pre></div><p>If we only wanted the 2nd and 3rd columns, we could run:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>awk <span style=color:#e6db74>&#39;{print $2 &#34; &#34; $3}&#39;</span> numbers.txt
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>2 3
</span></span><span style=display:flex><span>5 6
</span></span></code></pre></div><p>(notice the blank <code>" "</code> we provide as a string to force some whitespace formatting
so the columns are closer to what exists in the original file.</p><ol start=3><li>Next, lets add in some additional text to print out:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>awk <span style=color:#e6db74>&#39;{print &#34;{\&#34;full_name\&#34;: \&#34;&#34; $0 &#34;\&#34;},&#34;}&#39;</span> names.txt
</span></span></code></pre></div><p>First thing you&rsquo;ll notice is a confusing array of <code>"</code></p><ul><li>the first <code>"</code> denotes the beginning of a string output for awk to print.
The subsequent <code>\"</code> are literal escaped quotes which we <em>want</em> to appear in the output.
We eventually end the first string with a standalone <code>"</code> to then print the line with the <code>$0</code> variable
and then we enter a string again to add the trailing bracket <code>}</code> and comma <code>,</code></li></ul><p>When run, this outputs:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>{&#34;full_name&#34;: &#34;john&#34;},
</span></span><span style=display:flex><span>{&#34;full_name&#34;: &#34;jack&#34;},
</span></span><span style=display:flex><span>{&#34;full_name&#34;: &#34;jill&#34;},
</span></span></code></pre></div><ol start=4><li>Now we&rsquo;re getting somewhere! Let&rsquo;s finish this off by adding the additional white spacing:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>awk <span style=color:#e6db74>&#39;{print &#34;{\n    \&#34;full_name\&#34;: \&#34;&#34; $0 &#34;\&#34;\n},&#34;}&#39;</span> names.txt
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>{
</span></span><span style=display:flex><span>    &#34;full_name&#34;: &#34;john&#34;
</span></span><span style=display:flex><span>},
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    &#34;full_name&#34;: &#34;jack&#34;
</span></span><span style=display:flex><span>},
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    &#34;full_name&#34;: &#34;jill&#34;
</span></span><span style=display:flex><span>},
</span></span></code></pre></div><p>The added whitespace within the strings (by including the literal escaped newlines <code>\n</code>)
are printed to give the correct, desired output!</p><ol start=5><li>Bonus: what if we wanted to remove the trailing comma?
What if we wanted to wrap this all in <code>[...]</code> to be closer to valid json?
Yeah, yeah, I know, <code>jq</code> exists, but by the power of our lord and savior awk,
all things possible!!</li></ol><p>To remove the trailing comma, we can use a sliding window technique:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>awk <span style=color:#e6db74>&#39;NR &gt; 1 {print prev &#34;,&#34;} {prev = &#34;{\n    \&#34;full_name\&#34;: \&#34;&#34; $0 &#34;\&#34;\n}&#34;} END {print prev}&#39;</span> names.txt
</span></span></code></pre></div><p>This introduces abit more complexity.</p><p>First, we add the <code>NR</code> concept: <code>NR</code> is the &ldquo;number of records&rdquo;.
This can be really useful for checking progress,
doing different things based on number of records processed, etc.</p><p>So, after the first record, we print the comma.
We also always store the &ldquo;previous&rdquo; chunk in a <code>prev</code> variable:
this is the N + 1 sliding window. Nothing actually happens when the first record is processed,
it&rsquo;s line output is simply stored in the <code>prev</code> variable to be printed on the next iteration.
This way, we&rsquo;re always one behind the current record
and when we reach the very end (using the <code>END</code> keyword),
we can print the previous chunk without the trailing comma!</p><p>To wrap it up the entire output in a square bracket and give it the correct spacing,
we can use this awk program:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-awk data-lang=awk><span style=display:flex><span>BEGIN {
</span></span><span style=display:flex><span>    <span style=color:#75715e># Print the opening bracket for the JSON array</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>print</span> <span style=color:#e6db74>&#34;[&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>NR <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e># after the first line, print the previously stored chunk</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>print</span> <span style=color:#a6e22e>prev</span> <span style=color:#e6db74>&#34;,&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e># Store the current line in a JSON object format</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>prev</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;    {\n        \&#34;full_name\&#34;: \&#34;&#34;</span> <span style=color:#f92672>$</span><span style=color:#ae81ff>0</span> <span style=color:#e6db74>&#34;\&#34;\n    }&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>END {
</span></span><span style=display:flex><span>    <span style=color:#75715e># Print the last line stored in prev and close the JSON array</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>print</span> <span style=color:#a6e22e>prev</span> <span style=color:#e6db74>&#34;\n]&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can run this awk program via a file instead of doing all of that on the command line directly.
This greatly helps with readability, maintainability, etc.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>awk -f format_names.awk names.txt
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>[
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        &#34;full_name&#34;: &#34;john&#34;
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        &#34;full_name&#34;: &#34;jack&#34;
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        &#34;full_name&#34;: &#34;jill&#34;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>Just like the previous awk program, we are printing each segment and then at the end,
leaving off the trailing comma. But this time, at the beginning of the program,
using <code>BEGIN</code> and <code>END</code>, we print an opening and closing bracket.</p><hr><p>Happy awk-ing and good luck!</p><hr><script src=https://giscus.app/client.js data-repo=jpmcb/blog data-repo-id="MDEwOlJlcG9zaXRvcnkxMTYxODMyNjg=" data-category="Blog comments" data-category-id=DIC_kwDOBuzQ5M4CTbHW data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://johncodes.com/>John McBride</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>