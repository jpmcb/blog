<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Job scheduling with tmux | John McBride</title>
<meta name=keywords content><meta name=description content="Tmux is one of my favorite utilities: it&rsquo;s a terminal multiplexer
that lets you create persistent shell sessions, panes, windows, etc. all within a single
terminal. It&rsquo;s a great way to organize your shell sessions and natively give you
multi-shell environments to work in without having to rely on a terminal program for those features.
You&rsquo;d think in a world of modern applications and fancy terminals
like iTerm 2 and Kitty, you wouldn&rsquo;t need such a utility. But time and time again,
tmux has proven itself to be a powerful and essential tool.
Especially when working with remote machines in the cloud or across SSH sessions,
tmux is critical in maintaining my organization and getting things done."><meta name=author content><link rel=canonical href=https://johncodes.com/posts/2024/01-15-tmux-scheduling/><link crossorigin=anonymous href=/assets/css/stylesheet.9329d037bc79464b26647fb72e079cd738f5d2418b1df4da3b515db9e22cb4d9.css integrity="sha256-kynQN7x5RksmZH+3Lgec1zj10kGLHfTaO1FdueIstNk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://johncodes.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://johncodes.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://johncodes.com/favicon-32x32.png><link rel=apple-touch-icon href=https://johncodes.com/apple-touch-icon.png><link rel=mask-icon href=https://johncodes.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://johncodes.com/posts/2024/01-15-tmux-scheduling/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Job scheduling with tmux"><meta property="og:description" content="Tmux is one of my favorite utilities: it&rsquo;s a terminal multiplexer
that lets you create persistent shell sessions, panes, windows, etc. all within a single
terminal. It&rsquo;s a great way to organize your shell sessions and natively give you
multi-shell environments to work in without having to rely on a terminal program for those features.
You&rsquo;d think in a world of modern applications and fancy terminals
like iTerm 2 and Kitty, you wouldn&rsquo;t need such a utility. But time and time again,
tmux has proven itself to be a powerful and essential tool.
Especially when working with remote machines in the cloud or across SSH sessions,
tmux is critical in maintaining my organization and getting things done."><meta property="og:type" content="article"><meta property="og:url" content="https://johncodes.com/posts/2024/01-15-tmux-scheduling/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-15T09:00:00+00:00"><meta property="article:modified_time" content="2024-01-15T09:00:00+00:00"><meta property="og:site_name" content="John-McBride"><meta name=twitter:card content="summary"><meta name=twitter:title content="Job scheduling with tmux"><meta name=twitter:description content="Tmux is one of my favorite utilities: it&rsquo;s a terminal multiplexer
that lets you create persistent shell sessions, panes, windows, etc. all within a single
terminal. It&rsquo;s a great way to organize your shell sessions and natively give you
multi-shell environments to work in without having to rely on a terminal program for those features.
You&rsquo;d think in a world of modern applications and fancy terminals
like iTerm 2 and Kitty, you wouldn&rsquo;t need such a utility. But time and time again,
tmux has proven itself to be a powerful and essential tool.
Especially when working with remote machines in the cloud or across SSH sessions,
tmux is critical in maintaining my organization and getting things done."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://johncodes.com/posts/"},{"@type":"ListItem","position":2,"name":"Job scheduling with tmux","item":"https://johncodes.com/posts/2024/01-15-tmux-scheduling/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Job scheduling with tmux","name":"Job scheduling with tmux","description":"Tmux is one of my favorite utilities: it\u0026rsquo;s a terminal multiplexer that lets you create persistent shell sessions, panes, windows, etc. all within a single terminal. It\u0026rsquo;s a great way to organize your shell sessions and natively give you multi-shell environments to work in without having to rely on a terminal program for those features.\nYou\u0026rsquo;d think in a world of modern applications and fancy terminals like iTerm 2 and Kitty, you wouldn\u0026rsquo;t need such a utility. But time and time again, tmux has proven itself to be a powerful and essential tool. Especially when working with remote machines in the cloud or across SSH sessions, tmux is critical in maintaining my organization and getting things done.\n","keywords":[],"articleBody":"Tmux is one of my favorite utilities: it’s a terminal multiplexer that lets you create persistent shell sessions, panes, windows, etc. all within a single terminal. It’s a great way to organize your shell sessions and natively give you multi-shell environments to work in without having to rely on a terminal program for those features.\nYou’d think in a world of modern applications and fancy terminals like iTerm 2 and Kitty, you wouldn’t need such a utility. But time and time again, tmux has proven itself to be a powerful and essential tool. Especially when working with remote machines in the cloud or across SSH sessions, tmux is critical in maintaining my organization and getting things done.\nBeyond multiplexing, tmux has some incredible capabilities that extend its functionality to be able to run and schedule jobs, automatically execute scripts within given contexts, and much more.\nLet’s look at a few use cases where we can schedule jobs to run and even create a whole production like environment, all organized and managed from tmux!\nRunning commands Tmux offers a way to run scripts in new sessions automatically:\ntmux new -s my-session -c /path/to/directory 'echo \"Hello Tmux!\" \u0026\u0026 sleep 100' Let’s break this down: this arbitrary example creates a new session named “my-session”, sets the session directory using the -c flag, and then executes a command.\nThis command will echo “Hello Tmux!” and then sleep for 100 seconds.\nWhen running this tmux command, we are automatically attached to the session and see “Hello Tmux!” printed at the top of the screen and then the sleep command takes over. Once the sleep command is done, the session exits.\nIf we wanted to run this in the background, we could provide the -d flag: this will keep the new session detached and run the given commands behind the scenes in the background.\n$ tmux new -s my-session -d -c ~/workspace 'echo \"hello world!\" \u0026\u0026 sleep 1000' $ tmux ls my-session: 1 windows (created Mon Jan 15 11:02:21 2024) Using tmux ls we can list out the current sessions and see my-session is running with 1 window in the background. This is part of the power of tmux: you can have sessions exist and persist outside of the current shell or session you are attached to. The sky is really the limit here and using multiple sessions, windows, and panes has become a cornerstone of my workflows.\nIf we wanted to attach to the session and see the progress of the command we gave it, we could run tmux a -t my-session. This will attach to the session named my-session.\nPersisting sessions This is all great, but not all that useful when need to latter observe the results of our command or persist the history: running a script for a new session or window or pane will automatically close once it’s completed.\nInstead, we can use a regular session we create and send it some commands remotely:\nAs an example, let’s say we needed to run some tests in the background on our Typescript project with npm run test and latter observe the results. We can do this with the send-keys command for sessions. Here, I’ll be using the OpenSauced API as my playground:\nCreate a new named session: # Create a new named, detached session # that starts in the given directory tmux new -s my-npm-tests -d -c ~/workspace/opensauced/api Send the command # Send the test command to the session tmux send-keys -t my-npm-tests \"npm run test\" Enter A few things to note here:\nEnter uses the special “key binding syntax” for sending a literal Enter key at the end of the command. If we needed to send something else, like “control c”, we could do that with C-c or M-c for “alt c”. Check the official man page where this has a full description of what’s possible with sending key bindings to sessions.\nAttach to the session: tmux a -t my-npm-tests Now that we’ve sent our test command to the session, at any point in the future we can attach to the session to see how it did and check the results. Since the session will be persisted after the command has run, there’s no rush to observe the results! The shell’s full history for that session will be right there when we need it!\nCheck results Within the attached session, we can see the full history of the npm command that was sent and check the results! This session is persisted so we can use the shell from this session to do additional work, detach, close it, etc.\n$ npm run test npm info using npm@9.6.7 npm info using node@v18.17.1 \u003e @open-sauced/api@2.3.0-beta.2 test \u003e jest npm info ok $ Script it! What if there are 5 or 6 things I want to do behind the scenes? Maybe I have a build and test process that can run many things in parallel at once? Instead of using send-keys manually, let’s create a small script that can do this all for us!\n#!/usr/bin/env bash # Create named, detached sessions tmux new -s npm-test -d -c ~/workspace/opensauced/api tmux new -s npm-build -d -c ~/workspace/opensauced/api # Send commands to the detached sessions tmux send-keys -t npm-test \"npm run test\" Enter tmux send-keys -t npm-build \"npm run build\" Enter Running this script yields the following tmux sessions:\n❯ tmux ls npm-build: 1 windows (created Mon Jan 15 11:31:28 2024) npm-test: 1 windows (created Mon Jan 15 11:31:28 2024) and can be attached to in order to inspect the results of each command.\nIf the commands to run within individual sessions is more complex than just a sole one liner, send-keys can also run a script or make command!\ntmux send-keys -t kubernetes \"make build\" Enter In this article, I’m assuming you always want to create a new session. But many of the same rules, flags, and syntaxes also apply to creating new windows, panes, etc. Tmux has a strong paradigm that is consistent across different ways to multi-plex shells so it’d be just as simple to create 2 windows instead of two panes that we then send commands to:\n#!/usr/bin/env bash # Create named windows tmux new-window -n npm-test -d -c ~/workspace/opensauced/api tmux new-window -n npm-build -d -c ~/workspace/opensauced/api # Send commands to the detached sessions tmux send-keys -t 0:npm-test \"npm run test\" Enter tmux send-keys -t 0:npm-build \"npm run build\" Enter A few things to note here: instead of -s for the session name, we provide -n for the new window name. You’ll also notice the send-keys syntax now includes a :. The first part is the name of the session (in my case, session named 0) and the name of the window to send the keys to.\nSetting env variables for sessions An important and powerful thing to remember here is environment variables: tmux provides the ability to denote global environment variables (env vars available to all new sessions) and session based env vars. In newer versions of tmux, I recommend setting the local session variable with the -e flag:\ntmux new -s my-session -d -e MYVAR=myvalue -c /dir This session named my-session will have access to the MYVAR environment variable we provided when creating the new session:\n$ echo $MYVAR myval Scheduling jobs with at and scripts One of the more powerful things I’ve used this all for is local job scheduling. Let’s look at 2 examples using at and scripts:\nOne off at scheduling at is a very basic command line utility that comes packaged with many desktop Linux distros and lets you do very simple one off scheduling.\nFor example, let’s say that you needed to do a git push 3 hours from now in a specific directory:\ntmux new -d -s git-push-later \\ -c /path/to/your/repo 'echo \"git push\" | at now + 3 hours' This will create a new detached session named git-push-later within the directory for your git repo and it sends git push to the at command via a pipe with the argument “now + 3 hours”.\nLooking at scheduled jobs via at:\n$ at -l 1 Mon Jan 15 14:46:00 2024 I can see there is a scheduled job! Cool!! This isn’t too much different than just running at manually from the given current directory, but it can be really useful and powerful if I’m working in a different directory or need to quickly load up some env vars. Better yet, you can easily combine this into a script that loads some global tmux environments to then execute many at commands in sequence.\nShell script scheduling There are alot of ways in Linux to do what I’m suggesting here, primarily through cron and crontab but sometimes for a quick and dirty job that needs to run on repeat every so often in a background shell, it can be quick and dirty to just wrap what I’m doing in a loop with a sleep command:\nwhile true; do # The command to continously run npm run test # Sleep for 5 minutes between runs sleep 5m done This can then be thrown in a script and executed via a tmux send-keys command like we’ve seen:\ntmux send-keys -t my-npm-tests \"./run-tests-every-5-mins.sh\" Enter Why do it this way and not just have a cron job in the background?\nFor observable things, like builds, tests, etc., I really like to have a persistent shell session that I can attach to, detach from, and occasionally keep track of.\nUsually with this method, these aren’t things that are too important, so if the tmux server dies, it’s nothing I can’t quickly spin back up with a little tmux script. It’s nice having a sort of “location” where these jobs are running in the background but always reachable from a different tmux window or tab. I sometimes find I’ve lost track of things Linux abstracts away with cron, systemd, etc. (which is generally a good thing: I don’t want to have to think about the things systemd is managing!) So, instead, for the little things I need to keep an eye on, I choose to keep track of them in a tmux session!\nBuilding production like environments Using all of this and with my weird tendency to keep track of things in tmux sessions, let’s build a simple production like environment using a starter script, docker, and a few tmux sessions!\nLet’s again look at an OpenSauced example: this starts a postgres database in docker, boots up the API (which will then attach to that database), and then starts the frontend:\n#!/usr/bin/env bash # Create named, detached sessions tmux new -s database -d -c ~/workspace/opensauced/api tmux new -s api -d -c ~/workspace/opensauced/api tmux new -s frontend -d -c ~/workspace/opensauced/app # Start the database up tmux send-keys -t database \"docker run -it --rm --name database -p 25060:5432 my_postgres_image:latest\" Enter # Start the API tmux send-keys -t api \"npm run start\" Enter # Start the frontend app tmux send-keys -t frontend \"npm run start\" Enter Horrifying, I know.\nBut surprisingly, I’ve found this to be a really great way to keep the various components of our system organized in a system I know well and can easily wrap my head around.\nThen, when I’m done with this environment, I can easily tear it down by stopping the tmux sessions:\ntmux kill-session database tmux kill-session api tmux kill-session frontend And that’s it! Easy organization, job scheduling, and multi-tasking with tmux!\n","wordCount":"1902","inLanguage":"en","datePublished":"2024-01-15T09:00:00Z","dateModified":"2024-01-15T09:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://johncodes.com/posts/2024/01-15-tmux-scheduling/"},"publisher":{"@type":"Organization","name":"John McBride","logo":{"@type":"ImageObject","url":"https://johncodes.com/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://johncodes.com/ accesskey=h title="John McBride (Alt + H)">John McBride</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://johncodes.com/archives title=Writing><span>Writing</span></a></li><li><a href=https://johncodes.com/index.xml title=RSS><span>RSS</span></a></li><li><a href=https://johncodes.com/talks/ title=Talks><span>Talks</span></a></li><li><a href=https://johncodes.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://johncodes.com/about title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Job scheduling with tmux</h1><div class=post-meta><span title='2024-01-15 09:00:00 +0000 UTC'>January 15, 2024</span></div></header><div class=post-content><p>Tmux is one of my favorite utilities: it&rsquo;s a terminal multiplexer
that lets you create persistent shell sessions, panes, windows, etc. all within a single
terminal. It&rsquo;s a great way to organize your shell sessions and natively give you
multi-shell environments to work in without having to rely on a terminal program for those features.</p><p>You&rsquo;d think in a world of modern applications and fancy terminals
like iTerm 2 and Kitty, you wouldn&rsquo;t need such a utility. But time and time again,
tmux has proven itself to be a powerful and essential tool.
Especially when working with remote machines in the cloud or across SSH sessions,
tmux is critical in maintaining my organization and getting things done.</p><p>Beyond multiplexing, tmux has some incredible capabilities that extend its functionality
to be able to run and schedule jobs, automatically execute scripts within given contexts,
and much more.</p><p>Let&rsquo;s look at a few use cases where we can schedule jobs to run
and even create a whole production like environment, all organized and managed from tmux!</p><h2 id=running-commands>Running commands<a hidden class=anchor aria-hidden=true href=#running-commands>#</a></h2><p>Tmux offers a way to run scripts in new sessions automatically:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>tmux new -s my-session -c /path/to/directory <span style=color:#e6db74>&#39;echo &#34;Hello Tmux!&#34; &amp;&amp; sleep 100&#39;</span>
</span></span></code></pre></div><p>Let&rsquo;s break this down: this arbitrary example creates a new session named &ldquo;my-session&rdquo;,
sets the session directory using the <code>-c</code> flag, and then executes a command.</p><p>This command will echo &ldquo;Hello Tmux!&rdquo; and then sleep for 100 seconds.</p><p>When running this tmux command, we are automatically attached to the session and see
&ldquo;Hello Tmux!&rdquo; printed at the top of the screen and then the <code>sleep</code> command takes over.
Once the <code>sleep</code> command is done, the session exits.</p><p>If we wanted to run this in the background, we could provide the <code>-d</code> flag: this will
keep the new session detached and run the given commands behind the scenes in the background.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ tmux new -s my-session -d -c ~/workspace &#39;echo &#34;hello world!&#34; &amp;&amp; sleep 1000&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ tmux ls
</span></span><span style=display:flex><span>my-session: 1 windows (created Mon Jan 15 11:02:21 2024)
</span></span></code></pre></div><p>Using <code>tmux ls</code> we can list out the current sessions and see <code>my-session</code> is running with 1 window in the background.
This is part of the power of tmux: you can have sessions exist and persist <em>outside</em>
of the current shell or session you are attached to. The sky is really the limit here
and using multiple sessions, windows, and panes has become a cornerstone of my workflows.</p><p>If we wanted to attach to the session and see the progress of the command we gave it, we could run <code>tmux a -t my-session</code>.
This will attach to the session named <code>my-session</code>.</p><h2 id=persisting-sessions>Persisting sessions<a hidden class=anchor aria-hidden=true href=#persisting-sessions>#</a></h2><p>This is all great, but not all that useful when need to latter observe the results of our command or persist the history:
running a script for a new session or window or pane will automatically close once it&rsquo;s completed.</p><p>Instead, we can use a regular session we create and send it some commands remotely:</p><p>As an example, let&rsquo;s say we needed to run some tests in the background on our Typescript project with <code>npm run test</code>
and latter observe the results. We can do this with the <code>send-keys</code> command for sessions.
Here, I&rsquo;ll be using the OpenSauced API as my playground:</p><ol><li>Create a new named session:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># Create a new named, detached session</span>
</span></span><span style=display:flex><span><span style=color:#75715e># that starts in the given directory</span>
</span></span><span style=display:flex><span>tmux new -s my-npm-tests -d -c ~/workspace/opensauced/api
</span></span></code></pre></div><ol start=2><li>Send the command</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># Send the test command to the session</span>
</span></span><span style=display:flex><span>tmux send-keys -t my-npm-tests <span style=color:#e6db74>&#34;npm run test&#34;</span> Enter
</span></span></code></pre></div><p>A few things to note here:</p><p><code>Enter</code> uses the special &ldquo;key binding syntax&rdquo; for sending a literal <code>Enter</code> key
at the end of the command. If we needed to send something else, like &ldquo;control c&rdquo;,
we could do that with <code>C-c</code> or <code>M-c</code> for &ldquo;alt c&rdquo;. Check the official man page
where this has <a href=http://man.openbsd.org/OpenBSD-current/man1/tmux.1#KEY_BINDINGS>a full description</a>
of what&rsquo;s possible with sending key bindings to sessions.</p><ol start=3><li>Attach to the session:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>tmux a -t my-npm-tests
</span></span></code></pre></div><p>Now that we&rsquo;ve sent our test command to the session, at any point in the future we can attach to the session to see
how it did and check the results. Since the session will be persisted after the
command has run, there&rsquo;s no rush to observe the results! The shell&rsquo;s full history for that session will be right there when we need it!</p><ol start=4><li>Check results</li></ol><p>Within the attached session, we can see the full history of the <code>npm</code> command
that was sent and check the results! This session is persisted so we can use the shell
from this session to do additional work, detach, close it, etc.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ npm run test
</span></span><span style=display:flex><span>npm info using npm@9.6.7
</span></span><span style=display:flex><span>npm info using node@v18.17.1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&gt; @open-sauced/api@2.3.0-beta.2 test
</span></span><span style=display:flex><span>&gt; jest
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>npm info ok
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$
</span></span></code></pre></div><h2 id=script-it>Script it!<a hidden class=anchor aria-hidden=true href=#script-it>#</a></h2><p>What if there are 5 or 6 things I want to do behind the scenes?
Maybe I have a build and test process that can run many things in parallel at once?
Instead of using <code>send-keys</code> manually, let&rsquo;s create a small script that can do this all for us!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e># Create named, detached sessions</span>
</span></span><span style=display:flex><span>tmux new -s npm-test -d -c ~/workspace/opensauced/api
</span></span><span style=display:flex><span>tmux new -s npm-build -d -c ~/workspace/opensauced/api
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Send commands to the detached sessions</span>
</span></span><span style=display:flex><span>tmux send-keys -t npm-test <span style=color:#e6db74>&#34;npm run test&#34;</span> Enter
</span></span><span style=display:flex><span>tmux send-keys -t npm-build <span style=color:#e6db74>&#34;npm run build&#34;</span> Enter
</span></span></code></pre></div><p>Running this script yields the following tmux sessions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>❯ tmux ls
</span></span><span style=display:flex><span>npm-build: 1 windows (created Mon Jan 15 11:31:28 2024)
</span></span><span style=display:flex><span>npm-test: 1 windows (created Mon Jan 15 11:31:28 2024)
</span></span></code></pre></div><p>and can be attached to in order to inspect the results of each command.</p><p>If the commands to run within individual sessions is more complex than just a sole one liner,
<code>send-keys</code> can also run a script or <code>make</code> command!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>tmux send-keys -t kubernetes <span style=color:#e6db74>&#34;make build&#34;</span> Enter
</span></span></code></pre></div><p>In this article, I&rsquo;m assuming you always want to create a new session.
But many of the same rules, flags, and syntaxes also apply to creating new windows, panes, etc.
Tmux has a strong paradigm that is consistent across different ways to multi-plex shells
so it&rsquo;d be just as simple to create 2 windows instead of two panes that we then send commands to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e># Create named windows</span>
</span></span><span style=display:flex><span>tmux new-window -n npm-test -d -c ~/workspace/opensauced/api
</span></span><span style=display:flex><span>tmux new-window -n npm-build -d -c ~/workspace/opensauced/api
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Send commands to the detached sessions</span>
</span></span><span style=display:flex><span>tmux send-keys -t 0:npm-test <span style=color:#e6db74>&#34;npm run test&#34;</span> Enter
</span></span><span style=display:flex><span>tmux send-keys -t 0:npm-build <span style=color:#e6db74>&#34;npm run build&#34;</span> Enter
</span></span></code></pre></div><p>A few things to note here: instead of <code>-s</code> for the session name, we provide <code>-n</code> for the new window name.
You&rsquo;ll also notice the <code>send-keys</code> syntax now includes a <code>:</code>. The first part is the name of the session (in my case, session named <code>0</code>)
and the name of the window to send the keys to.</p><h3 id=setting-env-variables-for-sessions>Setting env variables for sessions<a hidden class=anchor aria-hidden=true href=#setting-env-variables-for-sessions>#</a></h3><p>An important and powerful thing to remember here is environment variables: tmux provides the ability to
denote global environment variables (env vars available to all new sessions)
and session based env vars. In newer versions of tmux, I recommend setting the local session
variable with the <code>-e</code> flag:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>tmux new -s my-session -d -e MYVAR<span style=color:#f92672>=</span>myvalue -c /dir
</span></span></code></pre></div><p>This session named <code>my-session</code> will have access to the <code>MYVAR</code> environment variable we provided when creating the new session:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ echo $MYVAR
</span></span><span style=display:flex><span>myval
</span></span></code></pre></div><h2 id=scheduling-jobs-with-at-and-scripts>Scheduling jobs with <code>at</code> and scripts<a hidden class=anchor aria-hidden=true href=#scheduling-jobs-with-at-and-scripts>#</a></h2><p>One of the more powerful things I&rsquo;ve used this all for is local job scheduling.
Let&rsquo;s look at 2 examples using <code>at</code> and scripts:</p><h4 id=one-off-at-scheduling>One off <code>at</code> scheduling<a hidden class=anchor aria-hidden=true href=#one-off-at-scheduling>#</a></h4><p><code>at</code> is a very basic command line utility that comes packaged with many desktop
Linux distros and lets you do very simple one off scheduling.</p><p>For example, let&rsquo;s say that you needed to do a git push 3 hours from now in a specific directory:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>tmux new -d -s git-push-later <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -c /path/to/your/repo <span style=color:#e6db74>&#39;echo &#34;git push&#34; | at now + 3 hours&#39;</span>
</span></span></code></pre></div><p>This will create a new detached session named <code>git-push-later</code> within the directory for your git repo
and it sends <code>git push</code> to the <code>at</code> command via a pipe with the argument &ldquo;now + 3 hours&rdquo;.</p><p>Looking at scheduled jobs via <code>at</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>$ at -l
</span></span><span style=display:flex><span>1       Mon Jan 15 14:46:00 2024
</span></span></code></pre></div><p>I can see there is a scheduled job! Cool!! This isn&rsquo;t <em>too</em> much different than
just running <code>at</code> manually from the given current directory, but it can be really useful and powerful
if I&rsquo;m working in a different directory or need to quickly load up some env vars.
Better yet, you can easily combine this into a script that loads some global tmux environments
to then execute many <code>at</code> commands in sequence.</p><h3 id=shell-script-scheduling>Shell script scheduling<a hidden class=anchor aria-hidden=true href=#shell-script-scheduling>#</a></h3><p>There are <em>alot</em> of ways in Linux to do what I&rsquo;m suggesting here, primarily through <code>cron</code> and <code>crontab</code>
but sometimes for a quick and dirty job that needs to run on repeat every so often in a background shell,
it can be quick and dirty to just wrap what I&rsquo;m doing in a loop with a sleep command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#66d9ef>while</span> true; <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># The command to continously run</span>
</span></span><span style=display:flex><span>    npm run test
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Sleep for 5 minutes between runs</span>
</span></span><span style=display:flex><span>    sleep 5m
</span></span><span style=display:flex><span><span style=color:#66d9ef>done</span>
</span></span></code></pre></div><p>This can then be thrown in a script and executed via a tmux <code>send-keys</code> command like we&rsquo;ve seen:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>tmux send-keys -t my-npm-tests <span style=color:#e6db74>&#34;./run-tests-every-5-mins.sh&#34;</span> Enter
</span></span></code></pre></div><p>Why do it this way and not just have a cron job in the background?</p><p>For observable things, like builds, tests, etc., I really like to have a persistent
shell session that I can attach to, detach from, and occasionally keep track of.</p><p>Usually with this method, these aren&rsquo;t things that are <em>too</em> important, so if the tmux
server dies, it&rsquo;s nothing I can&rsquo;t quickly spin back up with a little tmux script. It&rsquo;s nice having a sort of &ldquo;location&rdquo;
where these jobs are running in the background but always reachable from a different tmux window or tab.
I sometimes find I&rsquo;ve lost track of things Linux abstracts away with <code>cron</code>, <code>systemd</code>, etc.
(which is generally a good thing: I don&rsquo;t want to have to think about the things <code>systemd</code> is managing!)
So, instead, for the little things I need to keep an eye on, I choose to keep track of them in a tmux session!</p><h2 id=building-production-like-environments>Building production like environments<a hidden class=anchor aria-hidden=true href=#building-production-like-environments>#</a></h2><p>Using all of this and with my weird tendency to keep track of things in tmux sessions,
let&rsquo;s build a simple production like environment using a starter script,
docker, and a few tmux sessions!</p><p>Let&rsquo;s again look at an OpenSauced example: this starts a postgres database in docker,
boots up the API (which will then attach to that database), and then starts the frontend:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env bash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e># Create named, detached sessions</span>
</span></span><span style=display:flex><span>tmux new -s database -d -c ~/workspace/opensauced/api
</span></span><span style=display:flex><span>tmux new -s api -d -c ~/workspace/opensauced/api
</span></span><span style=display:flex><span>tmux new -s frontend -d -c ~/workspace/opensauced/app
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Start the database up</span>
</span></span><span style=display:flex><span>tmux send-keys -t database <span style=color:#e6db74>&#34;docker run -it --rm --name database -p 25060:5432 my_postgres_image:latest&#34;</span> Enter
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Start the API</span>
</span></span><span style=display:flex><span>tmux send-keys -t api <span style=color:#e6db74>&#34;npm run start&#34;</span> Enter
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Start the frontend app</span>
</span></span><span style=display:flex><span>tmux send-keys -t frontend <span style=color:#e6db74>&#34;npm run start&#34;</span> Enter
</span></span></code></pre></div><p>Horrifying, I know.</p><p>But surprisingly, I&rsquo;ve found this to be a really great way to keep the various
components of our system organized in a system I know well and can easily wrap my head around.</p><p>Then, when I&rsquo;m done with this environment, I can easily tear it down by stopping the tmux sessions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>tmux kill-session database
</span></span><span style=display:flex><span>tmux kill-session api
</span></span><span style=display:flex><span>tmux kill-session frontend
</span></span></code></pre></div><p>And that&rsquo;s it! Easy organization, job scheduling, and multi-tasking with tmux!</p><hr><script src=https://giscus.app/client.js data-repo=jpmcb/blog data-repo-id="MDEwOlJlcG9zaXRvcnkxMTYxODMyNjg=" data-category="Blog comments" data-category-id=DIC_kwDOBuzQ5M4CTbHW data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=dark_dimmed data-lang=en data-loading=lazy crossorigin=anonymous async></script></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://johncodes.com/>John McBride</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>